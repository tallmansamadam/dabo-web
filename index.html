<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dabo // Ferengi Terminal</title>

  <!--
    Dabo Ferengi Web (single-file app)
    - Click-only slot selection via ruler + chips (no redundant text entry).
    - 3 rings: cruise -> decelerate -> deterministic stop, A then B then C.
    - Responsive layout: clamp sizing, wrapping, ruler scroll, reduced-motion support.
  -->

  <style>
    :root{
      /* Base terminal palette */
      --bg0:#060707;
      --bg1:#0a0c0b;
      --ink:#b7ffbf;           /* phosphor */
      --ink2:#7bff8f;
      --warn:#ffd07a;
      --bad:#ff7a7a;

      /* Brass accents */
      --brass2:#d2a84b;
      --brass3:#f7d57e;

      /* Grid glow */
      --grid: rgba(90, 180, 120, 0.08);
      --glow: 0 0 10px rgba(120,255,160,0.25), 0 0 30px rgba(120,255,160,0.09);

      /* Responsive sizing primitives */
      --cell: clamp(26px, 3.2vw, 48px); /* per-symbol cell size */
      --gap: clamp(4px, 0.8vw, 8px);

      --radius: 16px;

      /* House-only (unbettable) contrast colors */
      --houseBg: rgba(255, 208, 122, 0.18);
      --houseBorder: rgba(255, 208, 122, 0.38);
      --houseText: rgba(255, 236, 190, 0.95);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: var(--ink);
      background:
        radial-gradient(1000px 700px at 20% 0%, rgba(90,180,120,0.10), transparent 55%),
        radial-gradient(800px 600px at 70% 20%, rgba(210,168,75,0.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* Wrapping rules so long text doesn't blow out divs */
    .wrap, .panel, .muted, .monoSmall { overflow-wrap:anywhere; word-break: normal; }

    .wrap{ max-width: 1120px; margin: 22px auto; padding: 0 16px 40px; }

    .frame{
      position:relative;
      border-radius: 26px;
      padding: 14px;
      background:
        linear-gradient(135deg, rgba(210,168,75,0.25), rgba(210,168,75,0.06) 35%, rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(30, 18, 4, 0.65), rgba(10, 8, 5, 0.75));
      box-shadow:
        0 18px 70px rgba(0,0,0,0.6),
        inset 0 0 0 1px rgba(247,213,126,0.18);
    }

    .terminal{
      position:relative;
      border-radius: 18px;
      padding: 18px;
      background:
        linear-gradient(180deg, rgba(10,24,18,0.92), rgba(6,12,9,0.92));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.12),
        inset 0 0 40px rgba(0,0,0,0.6);
      overflow:hidden;
      min-width: 0;
    }

    /* scanlines + subtle CRT shimmer */
    .terminal:before{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.05) 0px,
          rgba(255,255,255,0.03) 1px,
          rgba(0,0,0,0.00) 2px,
          rgba(0,0,0,0.00) 5px
        );
      opacity:0.10;
      pointer-events:none;
    }
    .terminal:after{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(closest-side at 30% 40%, rgba(120,255,160,0.08), transparent 60%),
        radial-gradient(closest-side at 70% 30%, rgba(210,168,75,0.08), transparent 65%);
      animation: shimmer 7s ease-in-out infinite alternate;
      pointer-events:none;
      opacity:0.9;
    }
    @keyframes shimmer{
      from{ transform: translate3d(-8px,-4px,0); filter: blur(0px); }
      to{ transform: translate3d(10px,8px,0); filter: blur(0.6px); }
    }

    .topbar{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 14px;
      position:relative;
      z-index:2;
    }
    .title{
      display:flex;
      gap:10px;
      align-items:baseline;
      flex-wrap:wrap;
      text-shadow: var(--glow);
      min-width: 0;
    }
    .title h1{
      margin:0;
      font-size: clamp(18px, 2.1vw, 24px);
      letter-spacing: 0.10em;
      font-weight: 900;
    }
    .subtitle{
      font-size: 12px;
      color: rgba(183,255,191,0.75);
      letter-spacing: 0.09em;
    }

    .statusrow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
      min-width: 0;
    }

    .pill{
      display:inline-flex;
      gap:10px;
      align-items:center;
      padding: 8px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(120,255,160,0.10), rgba(120,255,160,0.04));
      box-shadow: inset 0 0 0 1px rgba(120,255,160,0.16);
      font-size: 12px;
      letter-spacing:0.06em;
      user-select:none;
      min-width: 0;
    }
    .pill strong{ color: var(--ink2); }
    .pillBrass{
      background: linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow: inset 0 0 0 1px rgba(210,168,75,0.28);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: 14px;
      margin-top: 14px;
      position:relative;
      z-index:2;
      min-width: 0;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: var(--radius);
      padding: 14px;
      background:
        linear-gradient(180deg, rgba(10,22,16,0.80), rgba(8,14,11,0.82));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.10),
        0 10px 30px rgba(0,0,0,0.35);
      position:relative;
      overflow:hidden;
      min-width: 0;
    }
    .panel:before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(90deg, transparent, rgba(90,180,120,0.12), transparent);
      opacity:0.25;
      transform: translateX(-60%);
      animation: sweep 9s linear infinite;
      pointer-events:none;
    }
    @keyframes sweep{
      0%{ transform: translateX(-60%); }
      100%{ transform: translateX(120%); }
    }

    .panel h2{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(183,255,191,0.82);
    }
    .muted{ color: rgba(183,255,191,0.68); font-size: 12px; line-height: 1.4; }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }
    .ok{ color: var(--ink2); }

    label{
      display:block;
      margin: 10px 0 6px;
      font-size: 12px;
      letter-spacing:0.08em;
      color: rgba(183,255,191,0.85);
    }
    input, button{
      font: inherit;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(120,255,160,0.18);
      background: rgba(0,0,0,0.25);
      color: var(--ink);
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
      min-width: 0;
    }
    input::placeholder{ color: rgba(183,255,191,0.35); }
    input:focus{
      border-color: rgba(120,255,160,0.40);
      box-shadow: 0 0 0 3px rgba(120,255,160,0.08), inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    button{
      cursor:pointer;
      border-color: rgba(210,168,75,0.35);
      background:
        linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 8px 18px rgba(0,0,0,0.35);
      letter-spacing:0.10em;
      text-transform: uppercase;
      font-weight: 900;
      white-space: nowrap;
    }
    button:hover{ filter: brightness(1.06); }
    button:disabled{ cursor:not-allowed; opacity:0.55; filter: saturate(0.7); }

    /* Wheel wrapper */
    .wheelWrap{
      border-radius: 18px;
      background:
        linear-gradient(180deg, rgba(210,168,75,0.12), rgba(0,0,0,0) 35%),
        linear-gradient(180deg, rgba(8,18,13,0.70), rgba(5,10,7,0.72));
      box-shadow:
        inset 0 0 0 1px rgba(247,213,126,0.20),
        inset 0 0 30px rgba(0,0,0,0.6),
        0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      position:relative;
      min-width: 0;
    }
    .wheelHeader{
      padding: 12px 12px 8px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      border-bottom: 1px solid rgba(120,255,160,0.12);
      position:relative;
      flex-wrap: wrap;
      min-width: 0;
    }
    .wheelHeader .muted{ font-size: 11px; letter-spacing:0.08em; }

    /* Slot ruler:
       - On wide viewports, it looks like a neat 36-step line.
       - On narrow viewports, it becomes horizontally scrollable to keep text legible. */
    .slotRulerWrap{
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      border-bottom: 1px dashed rgba(120,255,160,0.10);
    }

    .slotRuler{
      display:flex;
      gap: 0;
      padding: 8px 10px 0;
      font-size: 10px;
      color: rgba(183,255,191,0.60);
      user-select:none;
      min-width: max-content; /* keep buttons readable; scroll if needed */
    }
    .slotRuler button{
      all: unset;
      cursor:pointer;
      text-align:center;
      padding: 2px 0 10px;
      width: clamp(18px, 2.2vw, 28px);
      position:relative;
      color: inherit;
      border-radius: 8px 8px 0 0;
      transition: transform 120ms ease, filter 120ms ease, background 120ms ease;
      scroll-snap-align: start;
    }
    .slotRuler button:hover{
      filter: brightness(1.1);
      transform: translateY(-1px);
      background: rgba(120,255,160,0.05);
    }

    /* House-only ruler buttons: higher-contrast background so numbers are readable */
    .slotRuler button.house{
      cursor:not-allowed;
      color: var(--houseText);
      background: var(--houseBg);
      box-shadow: inset 0 0 0 1px var(--houseBorder);
      transform:none !important;
      filter:none !important;
    }

    .slotRuler button.selected{
      color: rgba(247,213,126,0.98);
      background: rgba(210,168,75,0.14);
      box-shadow: inset 0 0 0 1px rgba(210,168,75,0.22);
    }
    .slotRuler button.selected::after{
      content:"";
      position:absolute; left:50%; bottom:-2px;
      width:0; height:0;
      border-left: 6px solid transparent;
      border-right:6px solid transparent;
      border-top: 7px solid rgba(210,168,75,0.85);
      transform: translateX(-50%);
      filter: drop-shadow(0 0 6px rgba(210,168,75,0.3));
    }

    .window{ position:relative; overflow:hidden; padding: 10px; min-width: 0; }
    .ringRow{ display:flex; align-items:center; gap: 10px; margin: 10px 0; min-width: 0; }
    .ringLabel{
      width: 86px;
      flex: 0 0 auto;
      font-size: 12px;
      letter-spacing:0.12em;
      text-transform: uppercase;
      color: rgba(183,255,191,0.75);
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .ringLabel b{ color: rgba(247,213,126,0.85); font-weight: 900; }

    .viewport{
      flex: 1 1 auto;
      min-width: 0;
      overflow:hidden;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(0,0,0,0.32), rgba(0,0,0,0.18));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.10),
        inset 0 0 18px rgba(0,0,0,0.55);
      position:relative;
    }
    .viewport:before{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(90deg, var(--grid) 0px, var(--grid) 1px, transparent 1px, transparent 24px);
      opacity:0.25;
      pointer-events:none;
    }

    .track{
      display:flex;
      width:max-content;
      will-change: transform;
      transform: translate3d(0,0,0);
      padding: 10px 10px;
      gap: var(--gap);
    }

    .cell{
      width: var(--cell);
      height: calc(var(--cell) * 0.92);
      border-radius: 12px;
      border: 1px solid rgba(120,255,160,0.12);
      background: linear-gradient(180deg, rgba(120,255,160,0.08), rgba(0,0,0,0.18));
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 3px 12px rgba(0,0,0,0.35);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap: 2px;
      user-select:none;
      position:relative;
      flex: 0 0 auto;
    }
    .cell .g{ font-size: 16px; filter: drop-shadow(0 0 10px rgba(120,255,160,0.15)); }
    .cell .t{ font-size: 10px; color: rgba(183,255,191,0.75); letter-spacing:0.06em; }

    /* House-only cells: match ruler contrast */
    .cell.house{
      background: linear-gradient(180deg, rgba(255,208,122,0.18), rgba(0,0,0,0.18));
      border-color: rgba(255,208,122,0.24);
    }
    .cell.house .t{ color: rgba(255,236,190,0.90); }

    .cell.selected{
      border-color: rgba(210,168,75,0.50);
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 0 0 2px rgba(210,168,75,0.22),
        0 8px 22px rgba(210,168,75,0.14);
    }

    .results{
      margin-top: 12px;
      border-top: 1px solid rgba(120,255,160,0.12);
      padding-top: 12px;
      min-width: 0;
    }

    table{ width:100%; border-collapse: collapse; font-size: 12px; margin-top: 8px; }
    th, td{ padding: 10px 8px; border-bottom: 1px solid rgba(120,255,160,0.10); text-align:left; }
    th{
      text-transform: uppercase;
      letter-spacing:0.10em;
      color: rgba(183,255,191,0.70);
      font-size: 11px;
    }

    .monoSmall{ font-size: 11px; letter-spacing:0.10em; color: rgba(183,255,191,0.82); }
    .ctaRow{ display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap; min-width: 0; }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 10px;
      min-height: 28px;
      min-width: 0;
    }
    .chip{
      display:inline-flex;
      gap: 8px;
      align-items:center;
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(210,168,75,0.10);
      border: 1px solid rgba(210,168,75,0.28);
      color: rgba(247,213,126,0.95);
      font-size: 11px;
      letter-spacing:0.08em;
      user-select:none;
    }
    .chip button{
      all: unset;
      cursor:pointer;
      font-weight: 900;
      padding: 0 6px;
      border-radius: 999px;
      color: rgba(247,213,126,0.95);
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(210,168,75,0.25);
    }
    .chip button:hover{ filter: brightness(1.1); }

    /* Accessibility: reduced motion */
    @media (prefers-reduced-motion: reduce){
      .terminal:after{ animation: none !important; }
      .panel:before{ animation: none !important; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="frame">
      <div class="terminal" id="terminal">

        <div class="topbar">
          <div class="title">
            <h1>DABO</h1>
            <div class="subtitle">QUARK‚ÄôS CHANCE ENGINE // FERENGI GAMING TERMINAL</div>
          </div>
          <div class="statusrow">
            <div class="pill pillBrass">LATINUM: <strong id="bankrollVal">1000</strong></div>
            <div class="pill">PAYOUT: <strong>Q+üåÄ+üåÄ</strong>=4000√ó ‚Ä¢ <strong>3K</strong>=100√ó ‚Ä¢ <strong>2K</strong>=5√ó</div>
          </div>
        </div>

        <div class="grid">
          <!-- Wheel panel -->
          <div class="panel">
            <h2>Wheel</h2>

            <div class="wheelWrap">
              <div class="wheelHeader">
                <div class="muted">
                  SELECT 1‚Äì3 SLOTS (HOUSE-ONLY: <span class="warn">5‚Äì7</span>, <span class="warn">17‚Äì19</span>, <span class="warn">29‚Äì31</span>)
                </div>
                <div class="muted">
                  Click slot numbers to toggle selection.
                </div>
              </div>

              <div class="slotRulerWrap">
                <div class="slotRuler" id="slotRuler" aria-label="Slot selector"></div>
              </div>

              <div class="window">
                <div class="ringRow">
                  <div class="ringLabel"><span>RING</span><b>A</b></div>
                  <div class="viewport"><div class="track" id="trackA"></div></div>
                </div>
                <div class="ringRow">
                  <div class="ringLabel"><span>RING</span><b>B</b></div>
                  <div class="viewport"><div class="track" id="trackB"></div></div>
                </div>
                <div class="ringRow">
                  <div class="ringLabel"><span>RING</span><b>C</b></div>
                  <div class="viewport"><div class="track" id="trackC"></div></div>
                </div>
              </div>
            </div>

            <div class="results">
              <div id="statusLine" class="monoSmall">SELECT SLOTS, ENTER BET, THEN SPIN.</div>
              <div id="spinMeta" class="muted" style="margin-top:8px;"></div>

              <table id="resultsTable" style="display:none;">
                <thead>
                  <tr>
                    <th>Slot</th>
                    <th>Ring A</th>
                    <th>Ring B</th>
                    <th>Ring C</th>
                    <th>Match</th>
                    <th>Mult</th>
                    <th>Win</th>
                  </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
              </table>
            </div>
          </div>

          <!-- Controls panel -->
          <div class="panel">
            <h2>Controls</h2>

            <label>SELECTED SLOTS</label>
            <div class="chips" id="chips"></div>
            <div id="slotsHint" class="muted"></div>

            <label for="betInput">BET PER SLOT</label>
            <input id="betInput" placeholder="10" autocomplete="off" inputmode="numeric" />
            <div id="betHint" class="muted" style="margin-top:6px;"></div>

            <div class="ctaRow" style="margin-top:12px;">
              <button id="spinBtn">Spin</button>
              <button id="clearBtn">Clear</button>
              <button id="resetBtn" title="Reset bankroll + wheel state">Reset</button>
            </div>

            <div class="muted" style="margin-top: 14px;">
              Note: If your system has ‚ÄúReduce Motion‚Äù enabled, the wheel will snap to the result.
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /**
   * ============================
   *  DABO: Core configuration
   * ============================
   */

  const SLOTS = 36;
  const MIN_BET = 10;
  const MAX_BET = 100;

  // House-only slots (unbettable). UI renders these differently and disables them.
  const UNBETTABLE = new Set([5,6,7,17,18,19,29,30,31]);

  // Symbol names (logic). UI glyphs are mapped separately to keep logic stable.
  const SYMBOLS = {
    BAR: 'BAR',
    ORB: 'ORB',
    COMET: 'COMET',
    BOLT: 'BOLT',
    MOON: 'MOON',
    SUN: 'SUN',
    SWIRL: 'SWIRL',
    DS9: 'DS9',
    QUARK: 'QUARK',
  };

  // Glyphs (presentation). Keep them simple for cross-platform font support.
  const GLYPH = {
    BAR: '‚ñÆ‚ñÆ',
    ORB: '‚óè',
    COMET: '‚òÑ',
    BOLT: '‚ö°',
    MOON: '‚òæ',
    SUN:  '‚òâ',
    SWIRL:'üåÄ',
    DS9:  '‚¨°',
    QUARK:'Q',
  };

  // A simple repeating base pattern (you can tune this later).
  const COMMON_PATTERN = [
    SYMBOLS.BAR, SYMBOLS.ORB, SYMBOLS.COMET, SYMBOLS.BOLT,
    SYMBOLS.MOON, SYMBOLS.SUN, SYMBOLS.BOLT, SYMBOLS.ORB,
  ];

  /**
   * Build a 36-symbol ring with a shift to differentiate ring A/B/C.
   * Also inject a few special icons at fixed positions (1-based indices).
   */
  function buildRing(seedShift = 0) {
    const ring = Array.from({ length: SLOTS }, (_, i) => COMMON_PATTERN[(i + seedShift) % COMMON_PATTERN.length]);

    // Special icons (1-based placement)
    ring[17 - 1] = SYMBOLS.QUARK;
    ring[8  - 1] = SYMBOLS.SWIRL;
    ring[28 - 1] = SYMBOLS.SWIRL;
    ring[11 - 1] = SYMBOLS.DS9;
    ring[22 - 1] = SYMBOLS.DS9;
    ring[34 - 1] = SYMBOLS.DS9;

    return ring;
  }

  const RING_A = buildRing(0);
  const RING_B = buildRing(3);
  const RING_C = buildRing(5);

  /**
   * ============================
   *  Randomness utilities
   * ============================
   *
   * We prefer WebCrypto when available. If a very old browser lacks it,
   * we fall back to Math.random. (Modern browsers support crypto.getRandomValues.)
   */
  function randInt(minInclusive, maxExclusive) {
    const range = maxExclusive - minInclusive;
    if (range <= 0) return minInclusive;

    try {
      if (globalThis.crypto?.getRandomValues) {
        const maxUint = 0xFFFFFFFF;
        const limit = maxUint - (maxUint % range);
        const buf = new Uint32Array(1);
        let x;
        do {
          globalThis.crypto.getRandomValues(buf);
          x = buf[0];
        } while (x >= limit);
        return minInclusive + (x % range);
      }
    } catch (_) {
      // fall through to Math.random
    }

    return minInclusive + Math.floor(Math.random() * range);
  }

  /**
   * ============================
   *  Game mechanics
   * ============================
   */

  function isBettable(slot1Based) {
    return slot1Based >= 1 && slot1Based <= SLOTS && !UNBETTABLE.has(slot1Based);
  }

  /**
   * Given ring stop offsets and a slot number N (1-based),
   * return the 3 symbols visible on that slot for rings A/B/C.
   */
  function symbolsAtSlot(slot1Based, offsets) {
    const i = (slot1Based - 1) % SLOTS;
    const sa = RING_A[(i + offsets.a) % SLOTS];
    const sb = RING_B[(i + offsets.b) % SLOTS];
    const sc = RING_C[(i + offsets.c) % SLOTS];
    return [sa, sb, sc];
  }

  /**
   * Payout multipliers:
   * - Jackpot: QUARK + SWIRL + SWIRL (any order): 4000x
   * - 3 of a kind: 100x
   * - 2 of a kind: 5x
   */
  function payoutMultiplier([sa, sb, sc]) {
    const trio = [sa, sb, sc].slice().sort().join('|');
    const jackpot = [SYMBOLS.QUARK, SYMBOLS.SWIRL, SYMBOLS.SWIRL].slice().sort().join('|');
    if (trio === jackpot) return 4000;
    if (sa === sb && sb === sc) return 100;
    if (sa === sb || sa === sc || sb === sc) return 5;
    return 0;
  }

  function matchLabel(mult) {
    if (mult === 4000) return 'JACK';
    if (mult === 100) return '3K';
    if (mult === 5) return '2K';
    return '--';
  }

  /**
   * ============================
   *  DOM wiring
   * ============================
   */

  const el = {
    bankrollVal: document.getElementById('bankrollVal'),
    betInput: document.getElementById('betInput'),
    betHint: document.getElementById('betHint'),
    slotsHint: document.getElementById('slotsHint'),
    chips: document.getElementById('chips'),

    slotRuler: document.getElementById('slotRuler'),

    trackA: document.getElementById('trackA'),
    trackB: document.getElementById('trackB'),
    trackC: document.getElementById('trackC'),

    spinBtn: document.getElementById('spinBtn'),
    clearBtn: document.getElementById('clearBtn'),
    resetBtn: document.getElementById('resetBtn'),

    statusLine: document.getElementById('statusLine'),
    spinMeta: document.getElementById('spinMeta'),
    resultsTable: document.getElementById('resultsTable'),
    resultsBody: document.getElementById('resultsBody'),
  };

  /**
   * ============================
   *  Selection state (click-only)
   * ============================
   */

  const state = {
    bankroll: 1000,
    selected: [],   // array of 1-based slot numbers (max 3)
    spinning: false,
  };

  function setStatus(msg, kind='muted') {
    el.statusLine.className = `monoSmall ${kind}`;
    el.statusLine.textContent = msg;
  }

  function updateBankroll() {
    el.bankrollVal.textContent = String(state.bankroll);
  }

  function setSpinning(on) {
    state.spinning = on;
    el.spinBtn.disabled = on;
    el.clearBtn.disabled = on;
    el.resetBtn.disabled = on;
    el.betInput.disabled = on;
  }

  function renderChips() {
    el.chips.innerHTML = '';
    if (state.selected.length === 0) {
      el.slotsHint.textContent = 'No slots selected.';
      return;
    }

    el.slotsHint.textContent = `Selected: ${state.selected.join(', ')}`;

    for (const slot of state.selected) {
      const chip = document.createElement('div');
      chip.className = 'chip';
      chip.innerHTML = `SLOT ${slot} <button title="Remove slot ${slot}">√ó</button>`;
      chip.querySelector('button').addEventListener('click', () => {
        state.selected = state.selected.filter(s => s !== slot);
        syncSelectionUI();
      });
      el.chips.appendChild(chip);
    }
  }

  function syncSelectionUI() {
    // Update ruler selected class
    [...el.slotRuler.querySelectorAll('button')].forEach(btn => {
      const s = Number(btn.dataset.slot);
      btn.classList.toggle('selected', state.selected.includes(s));
    });

    // Highlight cells for selected slots (all copies)
    const tracks = [el.trackA, el.trackB, el.trackC];
    for (const tr of tracks) {
      [...tr.children].forEach(cell => {
        const s = Number(cell.dataset.slot);
        cell.classList.toggle('selected', state.selected.includes(s));
      });
    }

    renderChips();
  }

  function toggleSlot(slot) {
    if (!isBettable(slot) || state.spinning) return;

    if (state.selected.includes(slot)) {
      state.selected = state.selected.filter(s => s !== slot);
    } else {
      if (state.selected.length >= 3) return; // enforce 1‚Äì3 slots max
      state.selected = [...state.selected, slot].sort((a,b)=>a-b);
    }
    syncSelectionUI();
  }

  function clearSelection() {
    state.selected = [];
    syncSelectionUI();
  }

  /**
   * ============================
   *  Wheel rendering (tracks)
   * ============================
   *
   * We render each ring as repeated copies to allow long scrolling without
   * requiring a massive DOM. We animate via transform translate3d(x,0,0).
   */

  const REPEAT = 5; // copies of 36 slots => 180 cells
  const CENTER_BAND_MIN = SLOTS * 1;
  const CENTER_BAND_MAX = SLOTS * 4; // keep position inside [36, 144) for safety

  function buildTrack(trackEl, ring, ringId) {
    trackEl.innerHTML = '';

    for (let rep = 0; rep < REPEAT; rep++) {
      for (let i = 0; i < SLOTS; i++) {
        const sym = ring[i];
        const slot1Based = i + 1;

        const d = document.createElement('div');
        d.className = 'cell';
        d.dataset.slot = String(slot1Based);
        d.dataset.sym = sym;
        d.dataset.ring = ringId;

        if (UNBETTABLE.has(slot1Based)) d.classList.add('house');

        const g = document.createElement('div');
        g.className = 'g';
        g.textContent = GLYPH[sym] ?? sym[0];

        const t = document.createElement('div');
        t.className = 't';
        t.textContent = sym;

        d.appendChild(g);
        d.appendChild(t);

        trackEl.appendChild(d);
      }
    }
  }

  function buildRuler() {
    el.slotRuler.innerHTML = '';
    for (let i = 1; i <= SLOTS; i++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = String(i);
      btn.dataset.slot = String(i);
      btn.setAttribute('aria-label', `Slot ${i}`);

      if (UNBETTABLE.has(i)) {
        btn.classList.add('house');
        btn.setAttribute('aria-disabled', 'true');
        // leave it clickable? no. block it.
      } else {
        btn.addEventListener('click', () => toggleSlot(i));
      }
      el.slotRuler.appendChild(btn);
    }
  }

  /**
   * ============================
   *  Animation math helpers
   * ============================
   */

  function prefersReducedMotion() {
    return globalThis.matchMedia && globalThis.matchMedia('(prefers-reduced-motion: reduce)').matches;
  }

  // Measure stride (cell width + gap) dynamically, because --cell uses clamp().
  function measureStridePx() {
    // Create a temp element that uses the same CSS variable
    const tmp = document.createElement('div');
    tmp.style.width = 'var(--cell)';
    tmp.style.position = 'absolute';
    tmp.style.visibility = 'hidden';
    document.body.appendChild(tmp);
    const w = tmp.getBoundingClientRect().width;
    tmp.remove();

    const g = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 6;
    return w + g;
  }

  let STRIDE_PX = 40; // updated at init + resize
  function applyShift(trackEl, posCells) {
    trackEl.style.transform = `translate3d(${-posCells * STRIDE_PX}px,0,0)`;
  }

  // Standard ease-out for deceleration.
  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  /**
   * Compute a target absolute position so that:
   *   target % 36 == desiredOffset
   * and target >= current + (revs * 36).
   *
   * We treat "position in cells" as equivalent to "offset index" for the spin.
   */
  function computeTargetPos(currentPos, desiredOffset) {
    const curMod = ((currentPos % SLOTS) + SLOTS) % SLOTS;
    const delta = (desiredOffset - curMod + SLOTS) % SLOTS;
    const extraRevs = randInt(5, 10); // 5..9 revolutions for visible spin
    return currentPos + extraRevs * SLOTS + delta;
  }

  /**
   * ============================
   *  Ring animation state machine
   * ============================
   *
   * Each ring:
   * - cruise: moves at constant velocity (cells/sec)
   * - decel: animates to a deterministic target using easing
   * - stopped: fixed at the final position
   */
  function makeRingAnim(trackEl) {
    return {
      trackEl,
      phase: 'idle',        // 'idle'|'cruise'|'decel'|'stopped'
      pos: SLOTS + randInt(0, SLOTS),  // keep inside repeat band
      vel: 0,               // cells/sec during cruise
      // decel params
      decelStartPos: 0,
      decelEndPos: 0,
      decelStartMs: 0,
      decelDurMs: 0,
      finalOffset: 0,       // chosen stop offset 0..35
    };
  }

  const ringA = makeRingAnim(el.trackA);
  const ringB = makeRingAnim(el.trackB);
  const ringC = makeRingAnim(el.trackC);

  // Apply initial transforms
  function applyAll() {
    applyShift(ringA.trackEl, ringA.pos);
    applyShift(ringB.trackEl, ringB.pos);
    applyShift(ringC.trackEl, ringC.pos);
  }

  /**
   * Keep positions inside the repeated band so transforms don‚Äôt drift too far.
   * (We rendered 5 copies => safe band is roughly [36, 144).)
   */
  function wrapPos(r) {
    while (r.pos >= CENTER_BAND_MAX) r.pos -= SLOTS;
    while (r.pos < CENTER_BAND_MIN) r.pos += SLOTS;
  }

  /**
   * Transition a ring from cruise -> decel to land on its finalOffset.
   * Duration is derived from distance, with caps for consistency across devices.
   */
  function startDecel(r, nowMs) {
    r.phase = 'decel';
    r.decelStartPos = r.pos;
    r.decelEndPos = computeTargetPos(r.pos, r.finalOffset);

    const distance = r.decelEndPos - r.decelStartPos; // in cells
    // Heuristic duration: faster devices will still look fine (time-based, not frame-based).
    const base = 850;
    const perRev = 120;
    const revs = Math.max(0, Math.floor(distance / SLOTS) - 1);
    r.decelDurMs = Math.min(1700, base + revs * perRev);

    r.decelStartMs = nowMs;
    r.vel = 0;
  }

  /**
   * Main animation loop:
   * - updates each ring depending on its phase
   * - applies transforms
   * - completes when all rings are stopped (then resolves via a Promise)
   */
  let rafId = 0;

  function tick(nowMs) {
    const dt = (nowMs - tick._lastMs) / 1000;
    tick._lastMs = nowMs;

    const rings = [ringA, ringB, ringC];

    for (const r of rings) {
      if (r.phase === 'cruise') {
        r.pos += r.vel * dt;
        wrapPos(r);
      } else if (r.phase === 'decel') {
        const t = Math.min(1, (nowMs - r.decelStartMs) / r.decelDurMs);
        const e = easeOutCubic(t);
        r.pos = r.decelStartPos + (r.decelEndPos - r.decelStartPos) * e;

        if (t >= 1) {
          r.pos = r.decelEndPos;
          r.phase = 'stopped';
          wrapPos(r);
        }
      }
    }

    applyAll();

    // Continue while any ring is moving.
    const anyMoving = rings.some(r => r.phase === 'cruise' || r.phase === 'decel');
    if (anyMoving) {
      rafId = requestAnimationFrame(tick);
    } else {
      tick._resolve?.();
    }
  }
  tick._lastMs = performance.now();

  function runAnimationUntilStop() {
    return new Promise(resolve => {
      tick._resolve = resolve;
      tick._lastMs = performance.now();
      rafId = requestAnimationFrame(tick);
    });
  }

  /**
   * ============================
   *  Input validation (bet only)
   * ============================
   */

  function validateBet(slotsCount) {
    const betRaw = el.betInput.value.trim();
    const bet = betRaw === '' ? MIN_BET : Number(betRaw);

    if (!Number.isInteger(bet)) {
      el.betHint.textContent = 'Bet must be a whole number.';
      return { ok:false, reason:'INVALID BET' };
    }

    const maxAffordablePerSlot = Math.floor(state.bankroll / Math.max(1, slotsCount));
    const effectiveMax = Math.min(MAX_BET, maxAffordablePerSlot);

    if (bet < MIN_BET || bet > effectiveMax) {
      el.betHint.textContent = `Bet per slot must be ${MIN_BET}‚Äì${effectiveMax} (based on bankroll).`;
      return { ok:false, reason:'BET OUT OF RANGE' };
    }

    el.betHint.textContent = `Total stake: ${bet * slotsCount}.`;
    return { ok:true, bet };
  }

  /**
   * ============================
   *  Results rendering
   * ============================
   */

  function renderResults(rows) {
    el.resultsBody.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.slot}</td>
        <td>${GLYPH[r.sa] ?? r.sa}</td>
        <td>${GLYPH[r.sb] ?? r.sb}</td>
        <td>${GLYPH[r.sc] ?? r.sc}</td>
        <td>${r.match}</td>
        <td>${r.mult}</td>
        <td>${r.win}</td>
      `;
      el.resultsBody.appendChild(tr);
    }
    el.resultsTable.style.display = '';
  }

  /**
   * ============================
   *  Spin orchestration
   * ============================
   */

  async function spin() {
    if (state.spinning) return;

    if (state.selected.length < 1 || state.selected.length > 3) {
      setStatus('ERROR // SELECT 1‚Äì3 BETTABLE SLOTS', 'bad');
      return;
    }

    const vb = validateBet(state.selected.length);
    if (!vb.ok) {
      setStatus(`ERROR // ${vb.reason}`, 'bad');
      return;
    }
    const bet = vb.bet;

    // Stake immediately (casino style).
    const stake = bet * state.selected.length;
    state.bankroll -= stake;
    updateBankroll();

    setSpinning(true);
    setStatus('SPINNING // WATCH THE WHEEL', 'warn');
    el.spinMeta.textContent = '';

    // Choose deterministic final offsets for each ring.
    const final = {
      a: randInt(0, SLOTS),
      b: randInt(0, SLOTS),
      c: randInt(0, SLOTS),
    };

    // Configure rings for cruise.
    // We use slightly different velocities so the rings feel independent.
    ringA.phase = 'cruise'; ringA.vel = randInt(22, 30);
    ringB.phase = 'cruise'; ringB.vel = randInt(26, 35);
    ringC.phase = 'cruise'; ringC.vel = randInt(30, 40);

    ringA.finalOffset = final.a;
    ringB.finalOffset = final.b;
    ringC.finalOffset = final.c;

    // Reduced motion: snap directly to final state (no animation).
    if (prefersReducedMotion()) {
      ringA.pos = computeTargetPos(ringA.pos, ringA.finalOffset);
      ringB.pos = computeTargetPos(ringB.pos, ringB.finalOffset);
      ringC.pos = computeTargetPos(ringC.pos, ringC.finalOffset);
      ringA.phase = ringB.phase = ringC.phase = 'stopped';
      wrapPos(ringA); wrapPos(ringB); wrapPos(ringC);
      applyAll();
    } else {
      // Schedule sequential decel starts: A then B then C
      const startMs = performance.now();
      const stopA = randInt(900, 1150);
      const stopB = randInt(1200, 1500);
      const stopC = randInt(1500, 1850);

      // Kick off the loop (it will run until all rings stop)
      const animPromise = runAnimationUntilStop();

      // Timers move rings into decel; ring continues ticking via rAF.
      setTimeout(() => startDecel(ringA, performance.now()), stopA);
      setTimeout(() => startDecel(ringB, performance.now()), stopB);
      setTimeout(() => startDecel(ringC, performance.now()), stopC);

      await animPromise;
    }

    // Evaluate outcome using final offsets (not derived from pos rounding).
    const rows = [];
    let totalWin = 0;

    for (const slot of state.selected) {
      const [sa, sb, sc] = symbolsAtSlot(slot, final);
      const mult = payoutMultiplier([sa, sb, sc]);
      const win = bet * mult;
      totalWin += win;
      rows.push({ slot, sa, sb, sc, mult, win, match: matchLabel(mult) });
    }

    state.bankroll += totalWin;
    updateBankroll();

    el.spinMeta.textContent = `Offsets: A=${final.a}, B=${final.b}, C=${final.c} ‚Äî Staked ${stake}, Won ${totalWin}, Net ${totalWin - stake}`;
    renderResults(rows);

    if (totalWin > 0) setStatus('DABO! // PROFIT ACHIEVED', 'ok');
    else setStatus('NO HIT // REASSESS YOUR STRATEGY', 'muted');

    if (state.bankroll < MIN_BET) {
      setStatus('INSUFFICIENT FUNDS // RESET REQUIRED', 'bad');
      el.spinBtn.disabled = true;
    }

    setSpinning(false);
  }

  function resetAll() {
    // Stop any running animation safely
    cancelAnimationFrame(rafId);
    tick._resolve = null;

    state.bankroll = 1000;
    updateBankroll();

    // Reset ring positions and states
    ringA.phase = ringB.phase = ringC.phase = 'idle';
    ringA.pos = SLOTS + randInt(0, SLOTS);
    ringB.pos = SLOTS + randInt(0, SLOTS);
    ringC.pos = SLOTS + randInt(0, SLOTS);
    applyAll();

    clearSelection();

    el.betInput.value = '';
    el.betHint.textContent = '';
    el.resultsTable.style.display = 'none';
    el.spinMeta.textContent = '';

    el.spinBtn.disabled = false;
    setStatus('SELECT SLOTS, ENTER BET, THEN SPIN.', 'muted');
  }

  /**
   * ============================
   *  Init
   * ============================
   */

  function initLayoutObservers() {
    // Recompute stride on resize/zoom/font changes.
    const recalc = () => {
      STRIDE_PX = measureStridePx();
      applyAll();
    };
    recalc();

    // ResizeObserver is widely supported; fall back to window resize if missing.
    if (globalThis.ResizeObserver) {
      const ro = new ResizeObserver(() => recalc());
      ro.observe(document.documentElement);
    } else {
      window.addEventListener('resize', recalc, { passive: true });
    }
  }

  function init() {
    buildRuler();
    buildTrack(el.trackA, RING_A, 'A');
    buildTrack(el.trackB, RING_B, 'B');
    buildTrack(el.trackC, RING_C, 'C');

    initLayoutObservers();

    updateBankroll();
    clearSelection();
    setStatus('SELECT SLOTS, ENTER BET, THEN SPIN.', 'muted');

    el.spinBtn.addEventListener('click', spin);
    el.clearBtn.addEventListener('click', () => { clearSelection(); setStatus('SELECTION CLEARED.', 'muted'); });
    el.resetBtn.addEventListener('click', resetAll);

    // Press Enter in bet field to spin
    el.betInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') spin();
    });

    // Keep bet hint up to date
    el.betInput.addEventListener('input', () => {
      if (state.selected.length > 0) validateBet(state.selected.length);
    });
  }

  init();
})();
</script>
</body>
</html>