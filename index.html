<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DABO // Ferengi Wheel</title>

  <style>
    :root{
      --bg0:#060707;
      --bg1:#0a0c0b;

      --ink:#b7ffbf;
      --ink2:#7bff8f;
      --warn:#ffd07a;
      --bad:#ff7a7a;

      --brass2:#d2a84b;
      --brass3:#f7d57e;

      /* Reserved / house-only slots (RED shading) */
      --reservedFill: rgba(255, 80, 80, 0.24);
      --reservedStroke: rgba(255, 90, 90, 0.70);
      --reservedText: rgba(255, 245, 245, 0.98);

      --radius: 16px;
      --gap: clamp(10px, 2.2vw, 16px);
      --wheelMax: 680px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: var(--ink);
      background:
        radial-gradient(1000px 700px at 20% 0%, rgba(90,180,120,0.10), transparent 55%),
        radial-gradient(800px 600px at 70% 20%, rgba(210,168,75,0.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    .wrap{ max-width: 1120px; margin: 22px auto; padding: 0 16px 40px; }

    .frame{
      border-radius: 26px;
      padding: 14px;
      background:
        linear-gradient(135deg, rgba(210,168,75,0.25), rgba(210,168,75,0.06) 35%, rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(30, 18, 4, 0.65), rgba(10, 8, 5, 0.75));
      box-shadow:
        0 18px 70px rgba(0,0,0,0.6),
        inset 0 0 0 1px rgba(247,213,126,0.18);
    }

    .terminal{
      position:relative;
      border-radius: 18px;
      padding: clamp(14px, 2vw, 18px);
      background: linear-gradient(180deg, rgba(10,24,18,0.92), rgba(6,12,9,0.92));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.12),
        inset 0 0 40px rgba(0,0,0,0.6);
      overflow:hidden;
    }
    .terminal:before{
      content:"";
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.05) 0px,
        rgba(255,255,255,0.03) 1px,
        rgba(0,0,0,0.00) 2px,
        rgba(0,0,0,0.00) 5px
      );
      opacity:0.10;
      pointer-events:none;
    }

    .topbar{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 14px;
      position:relative;
      z-index:2;
    }

    .title{
      display:flex;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
      min-width: 0;
      text-shadow: 0 0 10px rgba(120,255,160,0.25);
    }
    .title h1{
      margin:0;
      font-weight: 900;
      letter-spacing: 0.10em;
      font-size: clamp(18px, 2.1vw, 24px);
      white-space: nowrap;
    }
    .subtitle{
      font-size: 12px;
      letter-spacing: 0.09em;
      color: rgba(183,255,191,0.75);
      max-width: 100%;
      overflow-wrap: break-word;
      word-break: normal;
    }

    .statusrow{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
      min-width: 0;
    }

    .pill{
      display:inline-flex;
      gap: 10px;
      align-items: center;
      padding: 8px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(120,255,160,0.10), rgba(120,255,160,0.04));
      box-shadow: inset 0 0 0 1px rgba(120,255,160,0.16);
      font-size: 12px;
      letter-spacing: 0.06em;
      user-select:none;

      white-space: nowrap; /* desktop */

      min-width: 0;
      max-width: 100%;
    }
    .pillBrass{
      background: linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow: inset 0 0 0 1px rgba(210,168,75,0.28);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: var(--gap);
      min-width: 0;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: var(--radius);
      padding: 14px;
      background: linear-gradient(180deg, rgba(10,22,16,0.80), rgba(8,14,11,0.82));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.10),
        0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      min-width: 0;
    }

    .panel h2{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(183,255,191,0.82);
    }

    .muted{
      color: rgba(183,255,191,0.68);
      font-size: 12px;
      line-height: 1.4;
      overflow-wrap: break-word;
    }
    .monoSmall{
      font-size: 11px;
      letter-spacing:0.10em;
      color: rgba(183,255,191,0.82);
      overflow-wrap: break-word;
    }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }
    .ok{ color: var(--ink2); }

    label{
      display:block;
      margin: 10px 0 6px;
      font-size: 12px;
      letter-spacing:0.08em;
      color: rgba(183,255,191,0.85);
    }
    input, button{
      font: inherit;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(120,255,160,0.18);
      background: rgba(0,0,0,0.25);
      color: var(--ink);
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
      min-width: 0;
      max-width: 100%;
    }
    input::placeholder{ color: rgba(183,255,191,0.35); }
    button{
      cursor:pointer;
      border-color: rgba(210,168,75,0.35);
      background: linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 8px 18px rgba(0,0,0,0.35);
      letter-spacing:0.10em;
      text-transform: uppercase;
      font-weight: 900;
      white-space: nowrap;
    }
    button:disabled{ cursor:not-allowed; opacity:0.55; filter: saturate(0.7); }

    .ctaRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 8px;
      min-height: 28px;
      min-width: 0;
    }
    .chip{
      display:inline-flex;
      gap: 8px;
      align-items:center;
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(210,168,75,0.10);
      border: 1px solid rgba(210,168,75,0.28);
      color: rgba(247,213,126,0.95);
      font-size: 11px;
      letter-spacing:0.08em;
      user-select:none;
      max-width: 100%;
      overflow-wrap: break-word;
    }
    .chip button{
      all: unset;
      cursor:pointer;
      font-weight: 900;
      padding: 0 6px;
      border-radius: 999px;
      color: rgba(247,213,126,0.95);
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(210,168,75,0.25);
    }

    .wheelShell{
      display:grid;
      place-items:center;
      width: 100%;
      max-width: var(--wheelMax);
      margin: 10px auto 0;
      aspect-ratio: 1;
      min-width: 0;
    }
    svg#wheelSvg{
      width: 100%;
      height: 100%;
      display:block;
      touch-action: manipulation;
      user-select:none;
    }

    .slotWedge{ cursor:pointer; }
    .slotWedge.house{ cursor:not-allowed; }

    .slotText{
      font-size: 14px;
      fill: rgba(183,255,191,0.85);
      paint-order: stroke;
      stroke: rgba(0,0,0,0.55);
      stroke-width: 3px;
      stroke-linejoin: round;
      user-select:none;
    }
    .slotText.house{
      fill: var(--reservedText);
      stroke: rgba(0,0,0,0.65);
    }

    .slotWedge.selected path{
      stroke: rgba(247,213,126,0.75) !important;
      stroke-width: 2.5 !important;
      filter: drop-shadow(0 0 10px rgba(247,213,126,0.18));
    }

    .symbolGlyph{
      font-size: 18px;
      fill: rgba(183,255,191,0.92);
      paint-order: stroke;
      stroke: rgba(0,0,0,0.55);
      stroke-width: 3px;
      stroke-linejoin: round;
      user-select:none;
    }

    /* Modal */
    .modal.hidden{ display:none; }
    .modal{
      position:fixed;
      inset:0;
      z-index:9999;
      display:grid;
      place-items:center;
      padding: clamp(10px, 3vw, 20px);
    }
    .modalBackdrop{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(2px);
    }
    .modalPanel{
      position:relative;
      width:min(980px, 100%);
      max-height:min(86vh, 820px);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(10,24,18,0.96), rgba(6,12,9,0.96));
      box-shadow:
        0 18px 70px rgba(0,0,0,0.7),
        inset 0 0 0 1px rgba(247,213,126,0.24),
        inset 0 0 40px rgba(0,0,0,0.55);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-width:0;
    }
    .modalHeader{
      padding: 14px 14px 10px;
      border-bottom: 1px solid rgba(120,255,160,0.12);
      display:flex;
      flex-direction:column;
      gap: 6px;
    }
    .modalTitle{
      font-weight: 900;
      letter-spacing: 0.14em;
      font-size: clamp(14px, 2.1vw, 18px);
      color: rgba(247,213,126,0.96);
    }
    .modalSub{
      font-size: 12px;
      letter-spacing: 0.08em;
      color: rgba(183,255,191,0.74);
      overflow-wrap: break-word;
    }

    .modalBody{
      padding: 14px;
      display:grid;
      grid-template-columns: 1fr 1.2fr;
      gap: 12px;
      min-width:0;
      overflow:auto;
    }

    /* Responsive ASCII: always fully visible, never scrolls */
    .ascii{
      margin:0;
      padding: 12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(210,168,75,0.22);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
      color: rgba(247,213,126,0.95);

      font-size: var(--asciiSize, clamp(10px, 1.7vw, 14px));
      line-height: 1.05;

      white-space: pre;
      overflow: hidden;

      max-width: 100%;
      max-height: min(52vh, 420px);
      min-width: 0;
    }

    .modalCopy{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .modalSummary{
      padding: 12px;
      border-radius: 14px;
      background: rgba(120,255,160,0.06);
      border: 1px solid rgba(120,255,160,0.14);
      overflow-wrap: break-word;
    }
    .modalRemark{
      padding: 12px;
      border-radius: 14px;
      background: rgba(210,168,75,0.10);
      border: 1px solid rgba(210,168,75,0.22);
      color: rgba(247,213,126,0.95);
      overflow-wrap: break-word;
    }
    .modalFooter{
      padding: 12px 14px 14px;
      border-top: 1px solid rgba(120,255,160,0.12);
      display:flex;
      justify-content:flex-end;
      gap: 10px;
    }

    @media (max-width: 760px){
      .modalBody{ grid-template-columns: 1fr; }
    }

    /* Portrait/mobile breakpoints: fix wrapping WITHOUT hurting desktop */
    @media (max-width: 520px){
      .statusrow{ justify-content:flex-start; }
      .pill{ white-space: normal; letter-spacing: 0.05em; }
      .title{ gap: 6px; }
      .title h1{ letter-spacing: 0.08em; }
      .subtitle{ letter-spacing: 0.05em; }
      .ascii{ max-height: min(42vh, 340px); }
    }

    @media (max-height: 560px){
      .modalPanel{ max-height: 92vh; }
      .modalBody{ padding: 10px; }
      .ascii{ max-height: min(36vh, 280px); }
    }

    @media (prefers-reduced-motion: reduce){
      .modalBackdrop{ backdrop-filter: none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="frame">
      <div class="terminal">

        <div class="topbar">
          <div class="title">
            <h1>DABO</h1>
            <div class="subtitle">TOP-DOWN WHEEL // FERENGI GAMING TERMINAL</div>
          </div>
          <div class="statusrow">
            <div class="pill pillBrass">LATINUM: <strong id="bankrollVal">1000</strong></div>
            <div class="pill">PAYOUT: <strong>Q+üåÄ+üåÄ</strong>=4000√ó ‚Ä¢ <strong>3K</strong>=100√ó ‚Ä¢ <strong>2K</strong>=5√ó</div>
          </div>
        </div>

        <div class="grid">
          <div class="panel">
            <h2>Wheel</h2>

            <div class="muted" id="hintLine">
              Tap/click slot numbers to select (1‚Äì3). Reserved slots are shaded red and disabled.
            </div>

            <div class="wheelShell" aria-label="Dabo wheel">
              <svg id="wheelSvg" viewBox="0 0 600 600" role="img" aria-label="Dabo wheel">
                <defs>
                  <radialGradient id="wheelGlow" cx="50%" cy="45%" r="60%">
                    <stop offset="0%" stop-color="rgba(120,255,160,0.08)"/>
                    <stop offset="60%" stop-color="rgba(0,0,0,0)"/>
                  </radialGradient>
                </defs>
                <rect x="0" y="0" width="600" height="600" fill="url(#wheelGlow)"></rect>

                <circle cx="300" cy="300" r="285" fill="rgba(0,0,0,0.18)" stroke="rgba(247,213,126,0.22)" stroke-width="3"></circle>

                <g id="slotRing"></g>
                <g id="ringA"></g>
                <g id="ringB"></g>
                <g id="ringC"></g>

                <circle cx="300" cy="300" r="70" fill="rgba(0,0,0,0.35)" stroke="rgba(120,255,160,0.14)" stroke-width="2"></circle>
                <text x="300" y="305" text-anchor="middle" class="symbolGlyph" style="font-size:20px; letter-spacing:0.18em;">DABO</text>

                <polygon points="300,18 290,38 310,38" fill="rgba(247,213,126,0.85)" stroke="rgba(0,0,0,0.6)" stroke-width="2"></polygon>
              </svg>
            </div>

            <div style="margin-top:12px;">
              <div id="statusLine" class="monoSmall">SELECT SLOTS, ENTER BET, THEN SPIN.</div>
              <div id="spinMeta" class="muted" style="margin-top:8px;"></div>

              <table id="resultsTable" style="display:none; width:100%; border-collapse:collapse; margin-top:10px; font-size:12px;">
                <thead>
                  <tr>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Slot</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">A</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">B</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">C</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Match</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Mult</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Win</th>
                  </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
              </table>
            </div>
          </div>

          <div class="panel">
            <h2>Controls</h2>

            <label>SELECTED SLOTS</label>
            <div class="chips" id="chips"></div>
            <div id="slotsHint" class="muted"></div>

            <label for="betInput">BET PER SLOT</label>
            <input id="betInput" placeholder="10" autocomplete="off" inputmode="numeric" />
            <div id="betHint" class="muted" style="margin-top:6px;"></div>

            <div class="ctaRow" style="margin-top:12px;">
              <button id="spinBtn">Spin</button>
              <button id="clearBtn">Clear</button>
              <button id="resetBtn">Reset</button>
            </div>

            <label style="margin-top:14px;">AUDIO</label>
            <div class="ctaRow" style="align-items:center;">
              <button id="muteBtn" type="button">SFX: ON</button>
              <input id="volSlider" type="range" min="0" max="100" value="70" style="width:min(260px, 100%);" />
            </div>
            <div class="muted" id="audioHint" style="margin-top:6px;">
              Audio begins after a click (browser autoplay rules).
            </div>

            <div class="muted" style="margin-top: 14px;">
              Reduce Motion enabled? The wheel snaps to results.
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Result modal -->
  <div id="resultModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modalBackdrop" data-close="1"></div>
    <div class="modalPanel" tabindex="-1">
      <div class="modalHeader">
        <div id="modalTitle" class="modalTitle">RESULT</div>
        <div id="modalSub" class="modalSub">Quark‚Äôs assessment pending‚Ä¶</div>
      </div>
      <div class="modalBody">
        <pre id="quarkAscii" class="ascii" aria-label="ASCII art"></pre>
        <div class="modalCopy">
          <div id="modalSummary" class="modalSummary"></div>
          <div id="modalRemark" class="modalRemark"></div>
        </div>
      </div>
      <div class="modalFooter">
        <button id="modalOk" class="modalOk">OK</button>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ========= Config =========
  const SLOTS = 36;
  const STEP_DEG = 360 / SLOTS; // 10 deg
  const MIN_BET = 10;
  const MAX_BET = 100;

  // Reserved / house-only slots
  const RESERVED = new Set([5,6,7,17,18,19,29,30,31]);

  const SYMBOLS = {
    BAR: 'BAR', ORB: 'ORB', COMET: 'COMET', BOLT: 'BOLT',
    MOON: 'MOON', SUN: 'SUN', SWIRL: 'SWIRL', DS9: 'DS9', QUARK: 'QUARK'
  };

  const GLYPH = {
    BAR: '‚ñÆ‚ñÆ', ORB: '‚óè', COMET: '‚òÑ', BOLT: '‚ö°',
    MOON: '‚òæ', SUN: '‚òâ', SWIRL:'üåÄ', DS9:'‚¨°', QUARK:'Q'
  };

  const COMMON_PATTERN = [
    SYMBOLS.BAR, SYMBOLS.ORB, SYMBOLS.COMET, SYMBOLS.BOLT,
    SYMBOLS.MOON, SYMBOLS.SUN, SYMBOLS.BOLT, SYMBOLS.ORB,
  ];

  function buildRing(seedShift = 0) {
    const ring = Array.from({ length: SLOTS }, (_, i) => COMMON_PATTERN[(i + seedShift) % COMMON_PATTERN.length]);
    ring[17 - 1] = SYMBOLS.QUARK;
    ring[8  - 1] = SYMBOLS.SWIRL;
    ring[28 - 1] = SYMBOLS.SWIRL;
    ring[11 - 1] = SYMBOLS.DS9;
    ring[22 - 1] = SYMBOLS.DS9;
    ring[34 - 1] = SYMBOLS.DS9;
    return ring;
  }

  const RING_A = buildRing(0);
  const RING_B = buildRing(3);
  const RING_C = buildRing(5);

  // ========= RNG =========
  function randInt(minInclusive, maxExclusive) {
    const range = maxExclusive - minInclusive;
    if (range <= 0) return minInclusive;

    try {
      if (globalThis.crypto?.getRandomValues) {
        const maxUint = 0xFFFFFFFF;
        const limit = maxUint - (maxUint % range);
        const buf = new Uint32Array(1);
        let x;
        do { globalThis.crypto.getRandomValues(buf); x = buf[0]; } while (x >= limit);
        return minInclusive + (x % range);
      }
    } catch (_) {}
    return minInclusive + Math.floor(Math.random() * range);
  }

  function prefersReducedMotion() {
    return globalThis.matchMedia && globalThis.matchMedia('(prefers-reduced-motion: reduce)').matches;
  }

  // ========= DOM =========
  const el = {
    bankrollVal: document.getElementById('bankrollVal'),
    betInput: document.getElementById('betInput'),
    betHint: document.getElementById('betHint'),
    slotsHint: document.getElementById('slotsHint'),
    chips: document.getElementById('chips'),

    statusLine: document.getElementById('statusLine'),
    spinMeta: document.getElementById('spinMeta'),

    resultsTable: document.getElementById('resultsTable'),
    resultsBody: document.getElementById('resultsBody'),

    spinBtn: document.getElementById('spinBtn'),
    clearBtn: document.getElementById('clearBtn'),
    resetBtn: document.getElementById('resetBtn'),

    slotRing: document.getElementById('slotRing'),
    ringA: document.getElementById('ringA'),
    ringB: document.getElementById('ringB'),
    ringC: document.getElementById('ringC'),

    // Audio UI
    muteBtn: document.getElementById('muteBtn'),
    volSlider: document.getElementById('volSlider'),
    audioHint: document.getElementById('audioHint'),

    // Modal
    modal: document.getElementById('resultModal'),
    modalBackdrop: document.querySelector('#resultModal .modalBackdrop'),
    modalTitle: document.getElementById('modalTitle'),
    modalSub: document.getElementById('modalSub'),
    modalSummary: document.getElementById('modalSummary'),
    modalRemark: document.getElementById('modalRemark'),
    quarkAscii: document.getElementById('quarkAscii'),
    modalOk: document.getElementById('modalOk'),
  };

  // ========= State =========
  const state = {
    bankroll: 1000,
    selected: [],
    spinning: false,
    rotA: 0, rotB: 0, rotC: 0,
    lastFocusEl: null,
  };

  function setStatus(msg, kind='muted') {
    el.statusLine.className = `monoSmall ${kind}`;
    el.statusLine.textContent = msg;
  }
  function updateBankroll() { el.bankrollVal.textContent = String(state.bankroll); }
  function setSpinning(on) {
    state.spinning = on;
    el.spinBtn.disabled = on;
    el.clearBtn.disabled = on;
    el.resetBtn.disabled = on;
    el.betInput.disabled = on;
  }

  // ========= Bet validation =========
  function validateBet(slotsCount) {
    const betRaw = el.betInput.value.trim();
    const bet = betRaw === '' ? MIN_BET : Number(betRaw);

    if (!Number.isInteger(bet)) {
      el.betHint.textContent = 'Bet must be a whole number.';
      return { ok:false, reason:'INVALID BET' };
    }

    const maxAffordablePerSlot = Math.floor(state.bankroll / Math.max(1, slotsCount));
    const effectiveMax = Math.min(MAX_BET, maxAffordablePerSlot);

    if (bet < MIN_BET || bet > effectiveMax) {
      el.betHint.textContent = `Bet per slot must be ${MIN_BET}‚Äì${effectiveMax} (based on bankroll).`;
      return { ok:false, reason:'BET OUT OF RANGE' };
    }

    el.betHint.textContent = `Total stake: ${bet * slotsCount}.`;
    return { ok:true, bet };
  }

  // ========= Payouts =========
  function payoutMultiplier([sa, sb, sc]) {
    const trio = [sa, sb, sc].slice().sort().join('|');
    const jackpot = [SYMBOLS.QUARK, SYMBOLS.SWIRL, SYMBOLS.SWIRL].slice().sort().join('|');
    if (trio === jackpot) return 4000;
    if (sa === sb && sb === sc) return 100;
    if (sa === sb || sa === sc || sb === sc) return 5;
    return 0;
  }
  function matchLabel(mult) {
    if (mult === 4000) return 'JACK';
    if (mult === 100) return '3K';
    if (mult === 5) return '2K';
    return '--';
  }
  function symbolsAtSlot(slot1Based, offsets) {
    const i = (slot1Based - 1) % SLOTS;
    const sa = RING_A[(i + offsets.a) % SLOTS];
    const sb = RING_B[(i + offsets.b) % SLOTS];
    const sc = RING_C[(i + offsets.c) % SLOTS];
    return [sa, sb, sc];
  }

  // ========= SVG geometry =========
  const CX = 300, CY = 300;
  const RAD = {
    slotIn: 240, slotOut: 280,
    aIn: 195, aOut: 235,
    bIn: 150, bOut: 190,
    cIn: 105, cOut: 145,
  };

  function degToRad(d) { return (d * Math.PI) / 180; }
  function polar(cx, cy, r, angleDeg) {
    const a = degToRad(angleDeg - 90);
    return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
  }
  function wedgePath(rInner, rOuter, startDeg, endDeg) {
    const p1 = polar(CX, CY, rOuter, startDeg);
    const p2 = polar(CX, CY, rOuter, endDeg);
    const p3 = polar(CX, CY, rInner, endDeg);
    const p4 = polar(CX, CY, rInner, startDeg);
    const largeArc = (endDeg - startDeg) > 180 ? 1 : 0;
    return [
      `M ${p1.x} ${p1.y}`,
      `A ${rOuter} ${rOuter} 0 ${largeArc} 1 ${p2.x} ${p2.y}`,
      `L ${p3.x} ${p3.y}`,
      `A ${rInner} ${rInner} 0 ${largeArc} 0 ${p4.x} ${p4.y}`,
      'Z'
    ].join(' ');
  }
  function uprightTextRotation(angleDeg) {
    const a = ((angleDeg % 360) + 360) % 360;
    return (a > 90 && a < 270) ? 180 : 0;
  }

  function clearGroup(g) { while (g.firstChild) g.removeChild(g.firstChild); }

  function buildSlotRing() {
    clearGroup(el.slotRing);

    for (let slot = 1; slot <= SLOTS; slot++) {
      const start = (slot - 1) * STEP_DEG;
      const end = slot * STEP_DEG;
      const mid = start + STEP_DEG / 2;

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.classList.add('slotWedge');
      g.dataset.slot = String(slot);

      const isReserved = RESERVED.has(slot);
      if (isReserved) g.classList.add('house');

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', wedgePath(RAD.slotIn, RAD.slotOut, start, end));
      path.setAttribute('stroke-width', '1.2');

      if (isReserved) {
        path.setAttribute('fill', 'var(--reservedFill)');
        path.setAttribute('stroke', 'var(--reservedStroke)');
      } else {
        path.setAttribute('fill', 'rgba(0,0,0,0.16)');
        path.setAttribute('stroke', 'rgba(120,255,160,0.16)');
      }

      const pos = polar(CX, CY, (RAD.slotIn + RAD.slotOut) / 2, mid);

      const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      txt.classList.add('slotText');
      if (isReserved) txt.classList.add('house');
      txt.setAttribute('x', pos.x);
      txt.setAttribute('y', pos.y);
      txt.setAttribute('text-anchor', 'middle');
      txt.setAttribute('dominant-baseline', 'middle');
      txt.textContent = String(slot);

      const flip = uprightTextRotation(mid);
      txt.setAttribute('transform', `rotate(${mid + flip} ${pos.x} ${pos.y})`);

      if (!isReserved) g.addEventListener('click', () => toggleSlot(slot));

      g.appendChild(path);
      g.appendChild(txt);
      el.slotRing.appendChild(g);
    }
  }

  function buildSymbolRing(groupEl, ringSymbols, rInner, rOuter) {
    clearGroup(groupEl);

    for (let i = 0; i < SLOTS; i++) {
      const start = i * STEP_DEG;
      const end = (i + 1) * STEP_DEG;
      const mid = start + STEP_DEG / 2;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', wedgePath(rInner, rOuter, start, end));
      path.setAttribute('fill', 'rgba(0,0,0,0.18)');
      path.setAttribute('stroke', 'rgba(120,255,160,0.12)');
      path.setAttribute('stroke-width', '1.0');

      const sym = ringSymbols[i];
      const glyph = GLYPH[sym] ?? sym[0];

      const pos = polar(CX, CY, (rInner + rOuter) / 2, mid);

      const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      txt.classList.add('symbolGlyph');
      txt.setAttribute('x', pos.x);
      txt.setAttribute('y', pos.y);
      txt.setAttribute('text-anchor', 'middle');
      txt.setAttribute('dominant-baseline', 'middle');
      txt.textContent = glyph;

      const flip = uprightTextRotation(mid);
      txt.setAttribute('transform', `rotate(${mid + flip} ${pos.x} ${pos.y})`);

      groupEl.appendChild(path);
      groupEl.appendChild(txt);
    }
  }

  // ========= Selection =========
  function syncSelectionUI() {
    el.slotRing.querySelectorAll('g.slotWedge').forEach(w => {
      const slot = Number(w.dataset.slot);
      w.classList.toggle('selected', state.selected.includes(slot));
    });
    renderChips();
  }

  function renderChips() {
    el.chips.innerHTML = '';
    if (state.selected.length === 0) {
      el.slotsHint.textContent = 'No slots selected.';
      return;
    }
    el.slotsHint.textContent = `Selected: ${state.selected.join(', ')}`;

    for (const slot of state.selected) {
      const chip = document.createElement('div');
      chip.className = 'chip';
      chip.innerHTML = `SLOT ${slot} <button title="Remove slot ${slot}">√ó</button>`;
      chip.querySelector('button').addEventListener('click', () => {
        state.selected = state.selected.filter(s => s !== slot);
        syncSelectionUI();
      });
      el.chips.appendChild(chip);
    }
  }

  function toggleSlot(slot) {
    if (state.spinning) return;
    if (RESERVED.has(slot)) return;

    if (state.selected.includes(slot)) {
      state.selected = state.selected.filter(s => s !== slot);
    } else {
      if (state.selected.length >= 3) return;
      state.selected = [...state.selected, slot].sort((a,b)=>a-b);
    }
    syncSelectionUI();
  }

  function clearSelection() { state.selected = []; syncSelectionUI(); }

  // ========= Rotation + animation =========
  function setGroupRotation(groupEl, deg) {
    groupEl.setAttribute('transform', `rotate(${deg} ${CX} ${CY})`);
  }
  function mod(n, m) { return ((n % m) + m) % m; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

  function computeTargetDeg(currentDeg, targetPhaseDeg, extraRevs) {
    const curPhase = mod(currentDeg, 360);
    const tgtPhase = mod(targetPhaseDeg, 360);

    let phaseDelta = tgtPhase - curPhase;
    phaseDelta = mod(phaseDelta, 360);
    if (phaseDelta > 0) phaseDelta -= 360; // CCW-only

    return currentDeg + phaseDelta - (extraRevs * 360);
  }

  function makeAnim(getDeg, setDeg) {
    return {
      phase: 'idle',
      getDeg, setDeg,
      vel: 0,
      decelStartDeg: 0,
      decelEndDeg: 0,
      decelStartMs: 0,
      decelDurMs: 0,
    };
  }

  const animA = makeAnim(() => state.rotA, d => { state.rotA = d; setGroupRotation(el.ringA, d); });
  const animB = makeAnim(() => state.rotB, d => { state.rotB = d; setGroupRotation(el.ringB, d); });
  const animC = makeAnim(() => state.rotC, d => { state.rotC = d; setGroupRotation(el.ringC, d); });

  function startDecel(anim, nowMs, endDeg, durMs) {
    anim.phase = 'decel';
    anim.decelStartDeg = anim.getDeg();
    anim.decelEndDeg = endDeg;
    anim.decelStartMs = nowMs;
    anim.decelDurMs = durMs;
    anim.vel = 0;
  }

  let rafId = 0;

  function runUntilStop() {
    return new Promise(resolve => {
      const last = { t: performance.now() };

      function tick(now) {
        const dt = (now - last.t) / 1000;
        last.t = now;

        const rings = [animA, animB, animC];

        for (const a of rings) {
          if (a.phase === 'cruise') {
            a.setDeg(a.getDeg() + a.vel * dt);
          } else if (a.phase === 'decel') {
            const t = Math.min(1, (now - a.decelStartMs) / a.decelDurMs);
            const e = easeOutCubic(t);
            a.setDeg(a.decelStartDeg + (a.decelEndDeg - a.decelStartDeg) * e);
            if (t >= 1) a.phase = 'stopped';
          }
        }

        const anyMoving = rings.some(a => a.phase === 'cruise' || a.phase === 'decel');
        if (anyMoving) rafId = requestAnimationFrame(tick);
        else resolve();
      }

      rafId = requestAnimationFrame(tick);
    });
  }

  // ========= Results table =========
  function renderResults(rows) {
    el.resultsBody.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.slot}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sa] ?? r.sa}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sb] ?? r.sb}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sc] ?? r.sc}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.match}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.mult}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.win}</td>
      `;
      el.resultsBody.appendChild(tr);
    }
    el.resultsTable.style.display = '';
  }

  // ========= AudioEngine (WebAudio synth) =========
  class AudioEngine {
    constructor() {
      this.ctx = null;
      this.master = null;
      this.enabled = true;
      this.volume = 0.70;

      this.spinSrc = null;
      this.spinGain = null;
      this.spinFilter = null;
      this.lfo = null;
      this.lfoGain = null;
    }

    loadPrefs() {
      const enabled = localStorage.getItem('dabo_audio_enabled');
      const vol = localStorage.getItem('dabo_audio_volume');
      if (enabled !== null) this.enabled = enabled === '1';
      if (vol !== null) this.volume = Math.max(0, Math.min(1, Number(vol)));
    }
    savePrefs() {
      localStorage.setItem('dabo_audio_enabled', this.enabled ? '1' : '0');
      localStorage.setItem('dabo_audio_volume', String(this.volume));
    }

    async ensureReady() {
      if (!this.enabled) return;
      if (!this.ctx) {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = this.volume;
        this.master.connect(this.ctx.destination);
      }
      if (this.ctx.state !== 'running') await this.ctx.resume();
    }

    setEnabled(on) {
      this.enabled = !!on;
      if (!this.enabled) this.stopSpin(true);
      this.savePrefs();
    }
    setVolume(v01) {
      this.volume = Math.max(0, Math.min(1, v01));
      if (this.master) this.master.gain.value = this.volume;
      this.savePrefs();
    }

    _noiseBuffer(seconds = 1.0) {
      const sr = this.ctx.sampleRate;
      const len = Math.floor(sr * seconds);
      const buf = this.ctx.createBuffer(1, len, sr);
      const data = buf.getChannelData(0);
      for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * 0.6;
      return buf;
    }

    startSpin() {
      if (!this.enabled || !this.ctx) return;
      this.stopSpin(true);

      const src = this.ctx.createBufferSource();
      src.buffer = this._noiseBuffer(1.0);
      src.loop = true;

      const filter = this.ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 900;
      filter.Q.value = 0.8;

      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0.0, this.ctx.currentTime);
      g.gain.linearRampToValueAtTime(0.40, this.ctx.currentTime + 0.10);

      const lfo = this.ctx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 3.5;

      const lfoGain = this.ctx.createGain();
      lfoGain.gain.value = 450;

      lfo.connect(lfoGain);
      lfoGain.connect(filter.frequency);

      src.connect(filter);
      filter.connect(g);
      g.connect(this.master);

      src.start();
      lfo.start();

      this.spinSrc = src;
      this.spinFilter = filter;
      this.spinGain = g;
      this.lfo = lfo;
      this.lfoGain = lfoGain;
    }

    stopSpin(immediate = false) {
      if (!this.spinSrc || !this.ctx) return;
      const t = this.ctx.currentTime;
      try {
        if (this.spinGain) {
          this.spinGain.gain.cancelScheduledValues(t);
          this.spinGain.gain.setValueAtTime(this.spinGain.gain.value, t);
          this.spinGain.gain.linearRampToValueAtTime(0.0, t + (immediate ? 0.02 : 0.25));
        }
        this.spinSrc.stop(t + (immediate ? 0.03 : 0.28));
        if (this.lfo) this.lfo.stop(t + (immediate ? 0.03 : 0.28));
      } catch (_) {}

      this.spinSrc = null;
      this.spinGain = null;
      this.spinFilter = null;
      this.lfo = null;
      this.lfoGain = null;
    }

    _beep(freq, dur, type='sine', gain=0.18, when=0) {
      if (!this.enabled || !this.ctx) return;
      const t0 = this.ctx.currentTime + when;

      const o = this.ctx.createOscillator();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);

      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0.0, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      o.connect(g);
      g.connect(this.master);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }

    playWin() {
      if (!this.enabled || !this.ctx) return;
      this._beep(660, 0.16, 'triangle', 0.16, 0.00);
      this._beep(880, 0.16, 'triangle', 0.16, 0.12);
      this._beep(1320,0.18, 'triangle', 0.16, 0.24);
    }

    playLose() {
      if (!this.enabled || !this.ctx) return;
      this._beep(110, 0.20, 'sine', 0.22, 0.00);
      this._beep(80,  0.24, 'sine', 0.18, 0.05);
    }

    // Generic win callout: system voice, not an impersonation.
    sayDabo() {
      if (!this.enabled) return;
      if (!('speechSynthesis' in window)) return;

      const u = new SpeechSynthesisUtterance('DABO!');
      u.rate = 1.05;
      u.pitch = 1.1;
      u.volume = Math.max(0, Math.min(1, this.volume));

      const voices = window.speechSynthesis.getVoices?.() || [];
      const v = voices.find(v => /en/i.test(v.lang)) || voices[0];
      if (v) u.voice = v;

      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    }
  }

  const audio = new AudioEngine();
  audio.loadPrefs();

  // ========= ASCII fit =========
  function fitAsciiToBox(preEl, minPx=8, maxPx=14) {
    if (!preEl) return true;
    let size = maxPx;
    preEl.style.setProperty('--asciiSize', `${size}px`);

    const fits = () => (preEl.scrollWidth <= preEl.clientWidth) && (preEl.scrollHeight <= preEl.clientHeight);

    while (!fits() && size > minPx) {
      size -= 0.5;
      preEl.style.setProperty('--asciiSize', `${size}px`);
    }
    return fits();
  }

  // ========= Modal content =========
  // ASCII generated from your provided image (transformed into text).
  const QUARK_ASCII_BIG = String.raw`
&@@@@@&&&&&&S3M&B99BBM:i252ssri;::.                    ,r, .XG&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
&@@@@@@&&&&@9hh9BBBBHi2SGh2XXXsr;,,                     s5s:  ;39@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@&&&&&&G#&&BBGA3#BGAsXsAX:.:,                  ,.. Ar;:   .sH&@@@@@@@@@@@@@@@@@@@@@@@@
@&@@@@@&@@&@@&@@&&#XM#BBHAiii;..::.          .. ....:i,..rS, i2:   :5#@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@529B&&G5Ar:. .:;,.    ,.   ...,:;:, :;..: ,h9H;,:  .sG&@@@@@@@@@@@@@@@@@@@
@@@@&&&&@@@@@@B9BBrHBBBB#M3Assriiri::::,,.     ..    .;;,  .ArMB9252i,  ;3B@@@@@@@@@@@@@@@@@
B@@@&&&&&@@@@@BMM#rHGhhS#HM52XAAAssi;:,        .   .:i:  .,2@92M9H5&#hs:  ,2#@@@@@@@@@@@@@@@
&@&&&&&&@@@@@@&#HSXrX2s;rA55AAA2AXi::,:,,,,,.,,:;:....:rXrrsA3hAH2X&@@9MA;   sG&@@@@@@@@@@@@
&@&&@&&&&@@@@@@&#HX3BB&9Ms::rssXXsrrr::;:,,,,,,,.  i23M3AXSBHr;2hrX&@@@@BHX;   iH&@@@@@@@@@@
@@@&@&&&&&@@@@@@B3M9H3SSHGGM32Xi;:;;:,,,....::::;AG#Bhi;,rG33HX53s3@@@@@@@BG2i   ;M&@@@@@@@@
@@@&&@&&&&@@@@@&HMG93#@&SH33H####9BBB#99Ghh5XiASMMh,5Ms. ;s:isr35X#@@@@@@@@@9H5i.  ;M&@@@@@@
@@@&&@@@@@@@@@@&sr3SA#&G9@@9M522539GHHs3#992i. rrX3M5r;. ,rr:;2XrX&&@@@@@@@@@&#G3i   iH@@@@@
@@@@&&@@@@@@@@@@A,XHXGhh9@@&hr:,r2HGMhXXir22r,. .:;;,,.  .rrX5r:i#&BBB&@@@@@@@@&#G3i   rG@@@
&@@@&&@@@@@@@@@@S.:hi35AM9@@#X;,.:rsAXii;rsAr.       .;:;X53Xs:;S@@@&BBB&&@@@@BH&B9G2:   X#@
&&@@@@@@@@@@@@@@@3,i3Xs..5B@&Mr;,.   ..;sssA:    .,,  iA52s:,;29@@@@&&&&BBBB&@&s3&BB#Ms   .2
&&@@@@@@@@@@@@@@@&5.;h2, r9&@&S32;;:,,::hAX3Aii;s3As, :X3Ars3#@@@@&&&&BB&@&&&&&GXB&&@BS5,   
&&@@@@@@@@@@@@@@@@@M,.AM2A5#@@@HG3si;;,:2h3HGSSHXr.;iiA5MSHH&@@@@@&&@@@&&&@@@&&@&@&B&@&9Hi  
&&@@@@@@@@@@@@@@@@@@9X..AHH9&@&9hGAsri;:.,  .::,,:s2is25h3X.5B@@@@@&@@@@@@@@@@@&B&&B&&@@&SX 
@@@@@@@@@@@@@@@@@@@@@@Bhsrs2G@&BHG5Arrss2Ari::iis:;srr23MA5A;rh9@@@B9B&@@@@@@@@@@&@&&&B@@&93
@@@@@@@@@@@@@@@@@@@@BSH3225G9@@&9MHM35Xrs;i;;srii;:,iA5GHrrA3;:shB@B#GGB@@@@@@@@@@@&&@BB&@@B
@@@@@@@@@@@@@&B#GGh53Mh22H#B@@@B##SSM#5rXsXAXrirsAr;r5GSHHA;H5Ai;2G9#GS&@@@@@@@@@@@@@@@&B&@@
@@@@@@@@BSHh52s: ;:,iX5552A39&@&##BBGG#2A552Ariii:. i##H55ShXXAMr;2G&BB@@@@@@@@@@@@@@@@@&B&@
@@@&9#M2;,isrii:;iAA225sA3H##B&@@&&&&#GMsi;:,      :3BM3h3XHhir5555h#SS9#99B9B&@@@@@@@@@@&B&
@@&hsA52sX2srrririsrs5MS999B&&B@@@@@@&&BGhXii::iiirA59#B9SM553s,:;XAhXA3sXX3sX5H9&@@@@@@@@&B
@@B33MhH2G5XXXr2A25MG#BB###9#S&@@@@@@@&&@@BGHGS##9M;sB#&@@9G3A25r:s2MA2h222Mh3hHG#@@@@@@@@@&
`;

  const QUARK_ASCII_COMPACT = String.raw`
      .-====-.
    .'  _  _  '.
   /   (o)(o)   \
  |     .--.     |
  |   .(____).   |
   \    '=='
    '._      _.'
       '-..-'
  "Latinum talks."
`;

  const QUARK_REMARKS = {
    jackpot: [
      "That‚Äôs not luck ‚Äî that‚Äôs destiny with a tab.",
      "Jackpot! I‚Äôll just‚Ä¶ hold onto your winnings for ‚Äúsafekeeping.‚Äù",
      "You hit the big one. Try not to faint on my floor.",
    ],
    win: [
      "A profit! I‚Äôm thrilled. Deeply. Spiritually. Now spin again.",
      "See? The wheel likes you. I‚Äôm not jealous. Not at all.",
      "Winnings! Don‚Äôt spend it all on ethics and self-respect.",
    ],
    loss: [
      "A learning experience! For you. Financially.",
      "The wheel is innocent. Your strategy, however‚Ä¶",
      "No hit. But think of the character you‚Äôre building. Very expensive character.",
    ]
  };

  function pick(arr) { return arr[randInt(0, arr.length)]; }

  function openModal({ title, sub, summaryHTML, remark }) {
    state.lastFocusEl = document.activeElement;

    el.modalTitle.textContent = title;
    el.modalSub.textContent = sub;
    el.modalSummary.innerHTML = summaryHTML;
    el.modalRemark.textContent = remark;

    el.quarkAscii.textContent = QUARK_ASCII_BIG;
    el.modal.classList.remove('hidden');

    requestAnimationFrame(() => {
      const ok = fitAsciiToBox(el.quarkAscii, 8, 14);
      if (!ok) {
        el.quarkAscii.textContent = QUARK_ASCII_COMPACT;
        requestAnimationFrame(() => fitAsciiToBox(el.quarkAscii, 9, 16));
      }
    });

    setTimeout(() => el.modalOk.focus(), 0);
  }

  function closeModal() {
    el.modal.classList.add('hidden');
    const restore = state.lastFocusEl;
    state.lastFocusEl = null;
    if (restore && typeof restore.focus === 'function') restore.focus();
    else el.spinBtn.focus();
  }

  function showResultModal({ stake, won, net, bankroll }) {
    let title, sub, remarkKey;
    if (won > 0 && net > 0) {
      title = (won >= stake * 1000) ? "JACKPOT RESULT" : "WIN RESULT";
      sub = "The wheel has spoken. Quark has opinions.";
      remarkKey = (won >= stake * 1000) ? "jackpot" : "win";
    } else {
      title = "LOSS RESULT";
      sub = "The wheel has spoken. Quark has‚Ä¶ relief.";
      remarkKey = "loss";
    }

    const summaryHTML = `
      <div><b>Stake:</b> ${stake}</div>
      <div><b>Winnings:</b> ${won}</div>
      <div><b>Net:</b> ${net}</div>
      <div><b>Bankroll:</b> ${bankroll}</div>
    `;

    openModal({
      title,
      sub,
      summaryHTML,
      remark: pick(QUARK_REMARKS[remarkKey]),
    });
  }

  el.modalOk.addEventListener('click', closeModal);
  el.modalBackdrop.addEventListener('click', closeModal);
  window.addEventListener('keydown', (e) => {
    if (!el.modal.classList.contains('hidden') && e.key === 'Escape') closeModal();
  });

  // ========= Spin =========
  async function spin() {
    if (state.spinning) return;

    if (state.selected.length < 1 || state.selected.length > 3) {
      setStatus('ERROR // SELECT 1‚Äì3 BETTABLE SLOTS', 'bad');
      return;
    }

    const vb = validateBet(state.selected.length);
    if (!vb.ok) {
      setStatus(`ERROR // ${vb.reason}`, 'bad');
      return;
    }
    const bet = vb.bet;

    const stake = bet * state.selected.length;
    state.bankroll -= stake;
    updateBankroll();

    setSpinning(true);
    setStatus('SPINNING // WATCH THE WHEEL', 'warn');
    el.spinMeta.textContent = '';
    el.resultsTable.style.display = 'none';

    await audio.ensureReady();
    audio.startSpin();

    const final = {
      a: randInt(0, SLOTS),
      b: randInt(0, SLOTS),
      c: randInt(0, SLOTS),
    };

    const targetPhaseA = -final.a * STEP_DEG;
    const targetPhaseB = -final.b * STEP_DEG;
    const targetPhaseC = -final.c * STEP_DEG;

    if (prefersReducedMotion()) {
      state.rotA = targetPhaseA; state.rotB = targetPhaseB; state.rotC = targetPhaseC;
      setGroupRotation(el.ringA, state.rotA);
      setGroupRotation(el.ringB, state.rotB);
      setGroupRotation(el.ringC, state.rotC);
      animA.phase = animB.phase = animC.phase = 'stopped';
    } else {
      animA.phase = 'cruise'; animA.vel = -randInt(220, 300);
      animB.phase = 'cruise'; animB.vel = -randInt(260, 340);
      animC.phase = 'cruise'; animC.vel = -randInt(300, 420);

      const endA = computeTargetDeg(state.rotA, targetPhaseA, randInt(5, 9));
      const endB = computeTargetDeg(state.rotB, targetPhaseB, randInt(6, 10));
      const endC = computeTargetDeg(state.rotC, targetPhaseC, randInt(7, 11));

      const loop = runUntilStop();

      setTimeout(() => startDecel(animA, performance.now(), endA, randInt(900, 1400)), randInt(700, 1000));
      setTimeout(() => startDecel(animB, performance.now(), endB, randInt(950, 1500)), randInt(950, 1250));
      setTimeout(() => startDecel(animC, performance.now(), endC, randInt(1000, 1600)), randInt(1200, 1500));

      await loop;

      state.rotA = targetPhaseA;
      state.rotB = targetPhaseB;
      state.rotC = targetPhaseC;
      setGroupRotation(el.ringA, state.rotA);
      setGroupRotation(el.ringB, state.rotB);
      setGroupRotation(el.ringC, state.rotC);
    }

    audio.stopSpin();

    const rows = [];
    let totalWin = 0;

    for (const slot of state.selected) {
      const [sa, sb, sc] = symbolsAtSlot(slot, final);
      const mult = payoutMultiplier([sa, sb, sc]);
      const win = bet * mult;
      totalWin += win;
      rows.push({ slot, sa, sb, sc, mult, win, match: matchLabel(mult) });
    }

    state.bankroll += totalWin;
    updateBankroll();

    const net = totalWin - stake;

    el.spinMeta.textContent =
      `Offsets: A=${final.a}, B=${final.b}, C=${final.c} ‚Äî Staked ${stake}, Won ${totalWin}, Net ${net}`;
    renderResults(rows);

    if (net > 0) {
      setStatus('DABO! // PROFIT ACHIEVED', 'ok');
      audio.playWin();
      audio.sayDabo(); // generic TTS ‚ÄúDABO!‚Äù
    } else {
      setStatus('NO HIT // REASSESS YOUR STRATEGY', 'muted');
      audio.playLose();
    }

    if (state.bankroll < MIN_BET) {
      setStatus('INSUFFICIENT FUNDS // RESET REQUIRED', 'bad');
      el.spinBtn.disabled = true;
    }

    setSpinning(false);

    showResultModal({ stake, won: totalWin, net, bankroll: state.bankroll });
  }

  function resetAll() {
    cancelAnimationFrame(rafId);

    state.bankroll = 1000;
    updateBankroll();

    state.rotA = 0; state.rotB = 0; state.rotC = 0;
    setGroupRotation(el.ringA, 0);
    setGroupRotation(el.ringB, 0);
    setGroupRotation(el.ringC, 0);

    animA.phase = animB.phase = animC.phase = 'idle';

    clearSelection();
    el.betInput.value = '';
    el.betHint.textContent = '';
    el.spinMeta.textContent = '';
    el.resultsTable.style.display = 'none';

    el.spinBtn.disabled = false;
    setStatus('SELECT SLOTS, ENTER BET, THEN SPIN.', 'muted');
  }

  // ========= Audio UI =========
  function initAudioUI() {
    el.volSlider.value = String(Math.round(audio.volume * 100));
    el.muteBtn.textContent = audio.enabled ? 'SFX: ON' : 'SFX: OFF';

    el.muteBtn.addEventListener('click', async () => {
      audio.setEnabled(!audio.enabled);
      el.muteBtn.textContent = audio.enabled ? 'SFX: ON' : 'SFX: OFF';
      if (audio.enabled) {
        await audio.ensureReady();
        el.audioHint.textContent = 'Audio ready.';
      } else {
        el.audioHint.textContent = 'Audio muted.';
      }
    });

    el.volSlider.addEventListener('input', () => {
      audio.setVolume(Number(el.volSlider.value) / 100);
    });

    if ('speechSynthesis' in window) {
      window.speechSynthesis.onvoiceschanged = () => window.speechSynthesis.getVoices();
    }
  }

  // ========= Init =========
  function init() {
    buildSlotRing();
    buildSymbolRing(el.ringA, RING_A, RAD.aIn, RAD.aOut);
    buildSymbolRing(el.ringB, RING_B, RAD.bIn, RAD.bOut);
    buildSymbolRing(el.ringC, RING_C, RAD.cIn, RAD.cOut);

    setGroupRotation(el.ringA, state.rotA);
    setGroupRotation(el.ringB, state.rotB);
    setGroupRotation(el.ringC, state.rotC);

    updateBankroll();
    clearSelection();
    setStatus('SELECT SLOTS, ENTER BET, THEN SPIN.', 'muted');

    el.spinBtn.addEventListener('click', spin);
    el.clearBtn.addEventListener('click', () => { clearSelection(); setStatus('SELECTION CLEARED.', 'muted'); });
    el.resetBtn.addEventListener('click', resetAll);

    el.betInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') spin(); });
    el.betInput.addEventListener('input', () => { if (state.selected.length > 0) validateBet(state.selected.length); });

    initAudioUI();

    window.addEventListener('resize', () => {
      if (!el.modal.classList.contains('hidden')) {
        requestAnimationFrame(() => {
          // Refit when viewport changes while modal is open
          const ok = fitAsciiToBox(el.quarkAscii, 8, 14);
          if (!ok) el.quarkAscii.textContent = QUARK_ASCII_COMPACT;
          requestAnimationFrame(() => fitAsciiToBox(el.quarkAscii, 9, 16));
        });
      }
    }, { passive:true });
  }

  init();
})();
</script>
</body>
</html>