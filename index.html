<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dabo // Ferengi Wheel</title>

  <!--
    ==========================================================
    DABO â€” FERENGI WHEEL UI (Single-file static web app)
    ==========================================================
    Goals solved in this revision:
      1) Wheel is a real top-down view: 3 concentric rings + outer slot ring.
      2) No "Ring A/B/C" labels: the wheel speaks for itself visually.
      3) No redundant slot input: slot selection is click/tap on wheel only.
      4) Responsiveness/wrapping: layout uses min-width:0, clamp(), and safe wrapping.
      5) House-only slots: distinct background and high-contrast numbers for readability.

    How the wheel works:
      - There are 36 slots. Each ring is a 36-element symbol array.
      - A "spin" selects offsets (0..35) for each ring.
      - For slot N (1-based), symbol = ring[(N - 1 + offset) % 36].
      - Visually, each ring rotates COUNTERCLOCKWISE by offset*(360/36)=offset*10 degrees,
        so the mapping matches the formula above.

    Accessibility:
      - If prefers-reduced-motion is enabled, animation snaps directly to result.

    Deployment:
      - Static host (Netlify): no build command, publish root.
  -->

  <style>
    :root{
      --bg0:#060707;
      --bg1:#0a0c0b;
      --panel:#0b120f;
      --ink:#b7ffbf;
      --ink2:#7bff8f;
      --warn:#ffd07a;
      --bad:#ff7a7a;

      --brass2:#d2a84b;
      --brass3:#f7d57e;

      /* House-only (unbettable) contrast */
      --houseFill: rgba(255, 208, 122, 0.22);
      --houseStroke: rgba(255, 208, 122, 0.55);
      --houseText: rgba(255, 245, 220, 0.98);

      /* Responsive typography and spacing */
      --radius: 16px;
      --gap: clamp(10px, 2.2vw, 16px);

      /* Wheel size behavior:
         - wheel container uses aspect-ratio:1 so it stays a circle.
         - svg scales automatically with width. */
      --wheelMax: 680px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: var(--ink);
      background:
        radial-gradient(1000px 700px at 20% 0%, rgba(90,180,120,0.10), transparent 55%),
        radial-gradient(800px 600px at 70% 20%, rgba(210,168,75,0.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* Global wrapping safety: prevents long strings from overflow */
    .wrap, .panel, .muted, .monoSmall, .pill { overflow-wrap:anywhere; min-width:0; }

    .wrap{ max-width: 1120px; margin: 22px auto; padding: 0 16px 40px; }

    .frame{
      border-radius: 26px;
      padding: 14px;
      background:
        linear-gradient(135deg, rgba(210,168,75,0.25), rgba(210,168,75,0.06) 35%, rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(30, 18, 4, 0.65), rgba(10, 8, 5, 0.75));
      box-shadow:
        0 18px 70px rgba(0,0,0,0.6),
        inset 0 0 0 1px rgba(247,213,126,0.18);
    }

    .terminal{
      position:relative;
      border-radius: 18px;
      padding: clamp(14px, 2vw, 18px);
      background: linear-gradient(180deg, rgba(10,24,18,0.92), rgba(6,12,9,0.92));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.12),
        inset 0 0 40px rgba(0,0,0,0.6);
      overflow:hidden;
    }

    /* CRT scanlines */
    .terminal:before{
      content:"";
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.05) 0px,
        rgba(255,255,255,0.03) 1px,
        rgba(0,0,0,0.00) 2px,
        rgba(0,0,0,0.00) 5px
      );
      opacity:0.10;
      pointer-events:none;
    }

    .topbar{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 14px;
      position:relative;
      z-index:2;
    }

    .title{
      display:flex;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
      min-width: 0;
      text-shadow: 0 0 10px rgba(120,255,160,0.25);
    }
    .title h1{
      margin:0;
      font-weight: 900;
      letter-spacing: 0.10em;
      font-size: clamp(18px, 2.1vw, 24px);
    }
    .subtitle{
      font-size: 12px;
      letter-spacing: 0.09em;
      color: rgba(183,255,191,0.75);
    }

    .statusrow{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
      min-width: 0;
    }

    .pill{
      display:inline-flex;
      gap: 10px;
      align-items: center;
      padding: 8px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(120,255,160,0.10), rgba(120,255,160,0.04));
      box-shadow: inset 0 0 0 1px rgba(120,255,160,0.16);
      font-size: 12px;
      letter-spacing: 0.06em;
      user-select:none;
      min-width: 0;
    }
    .pillBrass{
      background: linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow: inset 0 0 0 1px rgba(210,168,75,0.28);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: var(--gap);
      min-width: 0;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: var(--radius);
      padding: 14px;
      background: linear-gradient(180deg, rgba(10,22,16,0.80), rgba(8,14,11,0.82));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.10),
        0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      min-width: 0;
    }

    .panel h2{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(183,255,191,0.82);
    }

    .muted{ color: rgba(183,255,191,0.68); font-size: 12px; line-height: 1.4; }
    .monoSmall{ font-size: 11px; letter-spacing:0.10em; color: rgba(183,255,191,0.82); }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }
    .ok{ color: var(--ink2); }

    label{ display:block; margin: 10px 0 6px; font-size: 12px; letter-spacing:0.08em; color: rgba(183,255,191,0.85); }
    input, button{
      font: inherit;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(120,255,160,0.18);
      background: rgba(0,0,0,0.25);
      color: var(--ink);
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
      min-width: 0;
    }
    input::placeholder{ color: rgba(183,255,191,0.35); }
    button{
      cursor:pointer;
      border-color: rgba(210,168,75,0.35);
      background: linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 8px 18px rgba(0,0,0,0.35);
      letter-spacing:0.10em;
      text-transform: uppercase;
      font-weight: 900;
      white-space: nowrap;
    }
    button:disabled{ cursor:not-allowed; opacity:0.55; filter: saturate(0.7); }

    .ctaRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 8px;
      min-height: 28px;
    }
    .chip{
      display:inline-flex;
      gap: 8px;
      align-items:center;
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(210,168,75,0.10);
      border: 1px solid rgba(210,168,75,0.28);
      color: rgba(247,213,126,0.95);
      font-size: 11px;
      letter-spacing:0.08em;
      user-select:none;
    }
    .chip button{
      all: unset;
      cursor:pointer;
      font-weight: 900;
      padding: 0 6px;
      border-radius: 999px;
      color: rgba(247,213,126,0.95);
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(210,168,75,0.25);
    }

    /* Wheel container: stays circular and scales responsibly */
    .wheelShell{
      display:grid;
      place-items:center;
      width: 100%;
      max-width: var(--wheelMax);
      margin: 0 auto;
      aspect-ratio: 1;
    }
    svg#wheelSvg{
      width: 100%;
      height: 100%;
      display:block;
    }

    /* SVG styling (strokes and text) */
    .slotWedge{ cursor:pointer; }
    .slotWedge.house{ cursor:not-allowed; }

    .slotText{
      font-size: 14px;
      fill: rgba(183,255,191,0.85);
      paint-order: stroke;
      stroke: rgba(0,0,0,0.55);
      stroke-width: 3px;
      stroke-linejoin: round;
      user-select:none;
    }
    .slotText.house{
      fill: var(--houseText);
      stroke: rgba(0,0,0,0.65);
    }

    .slotWedge.selected path{
      stroke: rgba(247,213,126,0.75) !important;
      stroke-width: 2.5 !important;
      filter: drop-shadow(0 0 10px rgba(247,213,126,0.18));
    }

    .symbolGlyph{
      font-size: 18px;
      fill: rgba(183,255,191,0.92);
      paint-order: stroke;
      stroke: rgba(0,0,0,0.55);
      stroke-width: 3px;
      stroke-linejoin: round;
      user-select:none;
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce){
      *{ scroll-behavior: auto !important; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="frame">
      <div class="terminal">

        <div class="topbar">
          <div class="title">
            <h1>DABO</h1>
            <div class="subtitle">TOP-DOWN WHEEL // FERENGI GAMING TERMINAL</div>
          </div>
          <div class="statusrow">
            <div class="pill pillBrass">LATINUM: <strong id="bankrollVal">1000</strong></div>
            <div class="pill">PAYOUT: <strong>Q+ðŸŒ€+ðŸŒ€</strong>=4000Ã— â€¢ <strong>3K</strong>=100Ã— â€¢ <strong>2K</strong>=5Ã—</div>
          </div>
        </div>

        <div class="grid">
          <div class="panel">
            <h2>Wheel</h2>

            <div class="muted" id="hintLine">
              Tap/click slot numbers to select (1â€“3). House-only slots are shaded and disabled.
            </div>

            <div class="wheelShell" aria-label="Dabo wheel">
              <!--
                SVG wheel:
                  - Outer ring = slot numbers (fixed, clickable)
                  - 3 inner rings = symbols, each rotates independently
                  - Pointer at top indicates the "read" position
              -->
              <svg id="wheelSvg" viewBox="0 0 600 600" role="img" aria-label="Dabo wheel">
                <!-- Background glow -->
                <defs>
                  <radialGradient id="wheelGlow" cx="50%" cy="45%" r="60%">
                    <stop offset="0%" stop-color="rgba(120,255,160,0.08)"/>
                    <stop offset="60%" stop-color="rgba(0,0,0,0)"/>
                  </radialGradient>
                </defs>
                <rect x="0" y="0" width="600" height="600" fill="url(#wheelGlow)"></rect>

                <!-- Outer rim -->
                <circle cx="300" cy="300" r="285" fill="rgba(0,0,0,0.18)" stroke="rgba(247,213,126,0.22)" stroke-width="3"></circle>

                <!-- Slot ring (clickable) gets generated into this group -->
                <g id="slotRing"></g>

                <!-- Symbol rings (generated wedges + glyph text) -->
                <g id="ringA"></g>
                <g id="ringB"></g>
                <g id="ringC"></g>

                <!-- Center hub -->
                <circle cx="300" cy="300" r="70" fill="rgba(0,0,0,0.35)" stroke="rgba(120,255,160,0.14)" stroke-width="2"></circle>
                <text x="300" y="305" text-anchor="middle" class="symbolGlyph" style="font-size:20px; letter-spacing:0.18em;">DABO</text>

                <!-- Pointer (top) -->
                <polygon points="300,18 290,38 310,38" fill="rgba(247,213,126,0.85)" stroke="rgba(0,0,0,0.6)" stroke-width="2"></polygon>
              </svg>
            </div>

            <div style="margin-top:12px;">
              <div id="statusLine" class="monoSmall">SELECT SLOTS, ENTER BET, THEN SPIN.</div>
              <div id="spinMeta" class="muted" style="margin-top:8px;"></div>

              <table id="resultsTable" style="display:none; width:100%; border-collapse:collapse; margin-top:10px; font-size:12px;">
                <thead>
                  <tr>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Slot</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">A</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">B</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">C</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Match</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Mult</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Win</th>
                  </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
              </table>
            </div>
          </div>

          <div class="panel">
            <h2>Controls</h2>

            <label>SELECTED SLOTS</label>
            <div class="chips" id="chips"></div>
            <div id="slotsHint" class="muted"></div>

            <label for="betInput">BET PER SLOT</label>
            <input id="betInput" placeholder="10" autocomplete="off" inputmode="numeric" />
            <div id="betHint" class="muted" style="margin-top:6px;"></div>

            <div class="ctaRow" style="margin-top:12px;">
              <button id="spinBtn">Spin</button>
              <button id="clearBtn">Clear</button>
              <button id="resetBtn">Reset</button>
            </div>

            <div class="muted" style="margin-top: 14px;">
              Reduce Motion enabled? The wheel will snap to results automatically.
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /**
   * ==========================================================
   * Constants / configuration
   * ==========================================================
   */
  const SLOTS = 36;
  const STEP_DEG = 360 / SLOTS; // 10 degrees per slot
  const MIN_BET = 10;
  const MAX_BET = 100;

  // House-only slots are unbettable; they get special styling.
  const UNBETTABLE = new Set([5,6,7,17,18,19,29,30,31]);

  // Symbols (logic) and glyphs (presentation).
  const SYMBOLS = {
    BAR: 'BAR',
    ORB: 'ORB',
    COMET: 'COMET',
    BOLT: 'BOLT',
    MOON: 'MOON',
    SUN: 'SUN',
    SWIRL: 'SWIRL',
    DS9: 'DS9',
    QUARK: 'QUARK',
  };

  // Keep glyphs simple for cross-platform rendering.
  const GLYPH = {
    BAR: 'â–®â–®',
    ORB: 'â—',
    COMET: 'â˜„',
    BOLT: 'âš¡',
    MOON: 'â˜¾',
    SUN:  'â˜‰',
    SWIRL:'ðŸŒ€',
    DS9:  'â¬¡',
    QUARK:'Q',
  };

  /**
   * A base repeating pattern. We then "seed shift" per ring and inject specials.
   * This is deliberately easy to tune later.
   */
  const COMMON_PATTERN = [
    SYMBOLS.BAR, SYMBOLS.ORB, SYMBOLS.COMET, SYMBOLS.BOLT,
    SYMBOLS.MOON, SYMBOLS.SUN, SYMBOLS.BOLT, SYMBOLS.ORB,
  ];

  function buildRing(seedShift = 0) {
    const ring = Array.from({ length: SLOTS }, (_, i) => COMMON_PATTERN[(i + seedShift) % COMMON_PATTERN.length]);

    // Special placements (1-based positions)
    ring[17 - 1] = SYMBOLS.QUARK;
    ring[8  - 1] = SYMBOLS.SWIRL;
    ring[28 - 1] = SYMBOLS.SWIRL;
    ring[11 - 1] = SYMBOLS.DS9;
    ring[22 - 1] = SYMBOLS.DS9;
    ring[34 - 1] = SYMBOLS.DS9;

    return ring;
  }

  const RING_A = buildRing(0);
  const RING_B = buildRing(3);
  const RING_C = buildRing(5);

  /**
   * ==========================================================
   * Randomness
   * ==========================================================
   * Prefer WebCrypto; fall back to Math.random if needed.
   */
  function randInt(minInclusive, maxExclusive) {
    const range = maxExclusive - minInclusive;
    if (range <= 0) return minInclusive;

    try {
      if (globalThis.crypto?.getRandomValues) {
        const maxUint = 0xFFFFFFFF;
        const limit = maxUint - (maxUint % range);
        const buf = new Uint32Array(1);
        let x;
        do {
          globalThis.crypto.getRandomValues(buf);
          x = buf[0];
        } while (x >= limit);
        return minInclusive + (x % range);
      }
    } catch (_) {}
    return minInclusive + Math.floor(Math.random() * range);
  }

  function prefersReducedMotion() {
    return globalThis.matchMedia && globalThis.matchMedia('(prefers-reduced-motion: reduce)').matches;
  }

  /**
   * ==========================================================
   * DOM bindings
   * ==========================================================
   */
  const el = {
    bankrollVal: document.getElementById('bankrollVal'),
    betInput: document.getElementById('betInput'),
    betHint: document.getElementById('betHint'),
    slotsHint: document.getElementById('slotsHint'),
    chips: document.getElementById('chips'),

    statusLine: document.getElementById('statusLine'),
    spinMeta: document.getElementById('spinMeta'),

    resultsTable: document.getElementById('resultsTable'),
    resultsBody: document.getElementById('resultsBody'),

    spinBtn: document.getElementById('spinBtn'),
    clearBtn: document.getElementById('clearBtn'),
    resetBtn: document.getElementById('resetBtn'),

    slotRing: document.getElementById('slotRing'),
    ringA: document.getElementById('ringA'),
    ringB: document.getElementById('ringB'),
    ringC: document.getElementById('ringC'),
  };

  /**
   * ==========================================================
   * State
   * ==========================================================
   */
  const state = {
    bankroll: 1000,
    selected: [],     // 1-based slot numbers (max 3)
    spinning: false,

    // Rotation state in degrees (unwrapped, can go negative large)
    rotA: 0,
    rotB: 0,
    rotC: 0,
  };

  function setStatus(msg, kind='muted') {
    el.statusLine.className = `monoSmall ${kind}`;
    el.statusLine.textContent = msg;
  }

  function updateBankroll() {
    el.bankrollVal.textContent = String(state.bankroll);
  }

  function setSpinning(on) {
    state.spinning = on;
    el.spinBtn.disabled = on;
    el.clearBtn.disabled = on;
    el.resetBtn.disabled = on;
    el.betInput.disabled = on;
  }

  /**
   * ==========================================================
   * Betting + validation
   * ==========================================================
   */
  function validateBet(slotsCount) {
    const betRaw = el.betInput.value.trim();
    const bet = betRaw === '' ? MIN_BET : Number(betRaw);

    if (!Number.isInteger(bet)) {
      el.betHint.textContent = 'Bet must be a whole number.';
      return { ok:false, reason:'INVALID BET' };
    }

    const maxAffordablePerSlot = Math.floor(state.bankroll / Math.max(1, slotsCount));
    const effectiveMax = Math.min(MAX_BET, maxAffordablePerSlot);

    if (bet < MIN_BET || bet > effectiveMax) {
      el.betHint.textContent = `Bet per slot must be ${MIN_BET}â€“${effectiveMax} (based on bankroll).`;
      return { ok:false, reason:'BET OUT OF RANGE' };
    }

    el.betHint.textContent = `Total stake: ${bet * slotsCount}.`;
    return { ok:true, bet };
  }

  /**
   * ==========================================================
   * Payout rules
   * ==========================================================
   */
  function payoutMultiplier([sa, sb, sc]) {
    const trio = [sa, sb, sc].slice().sort().join('|');
    const jackpot = [SYMBOLS.QUARK, SYMBOLS.SWIRL, SYMBOLS.SWIRL].slice().sort().join('|');
    if (trio === jackpot) return 4000;
    if (sa === sb && sb === sc) return 100;
    if (sa === sb || sa === sc || sb === sc) return 5;
    return 0;
  }

  function matchLabel(mult) {
    if (mult === 4000) return 'JACK';
    if (mult === 100) return '3K';
    if (mult === 5) return '2K';
    return '--';
  }

  /**
   * For a slot N (1-based), apply offset mapping:
   * symbol = ring[(N - 1 + offset) % 36]
   */
  function symbolsAtSlot(slot1Based, offsets) {
    const i = (slot1Based - 1) % SLOTS;
    const sa = RING_A[(i + offsets.a) % SLOTS];
    const sb = RING_B[(i + offsets.b) % SLOTS];
    const sc = RING_C[(i + offsets.c) % SLOTS];
    return [sa, sb, sc];
  }

  /**
   * ==========================================================
   * SVG geometry helpers
   * ==========================================================
   *
   * We generate wedge paths for each of 36 sectors.
   * Angles:
   *   - slot 1 is centered at the top (12 o'clock).
   *   - we use SVG polar coordinates where 0Â° is at the top by offsetting -90Â°.
   */
  const CX = 300, CY = 300;

  function degToRad(d) { return (d * Math.PI) / 180; }

  // Convert polar angle (degrees) + radius to x,y. Angle 0Â° at top.
  function polar(cx, cy, r, angleDeg) {
    const a = degToRad(angleDeg - 90);
    return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
  }

  // Create a donut-sector wedge path from startAngle to endAngle.
  function wedgePath(rInner, rOuter, startDeg, endDeg) {
    const p1 = polar(CX, CY, rOuter, startDeg);
    const p2 = polar(CX, CY, rOuter, endDeg);
    const p3 = polar(CX, CY, rInner, endDeg);
    const p4 = polar(CX, CY, rInner, startDeg);

    const largeArc = (endDeg - startDeg) > 180 ? 1 : 0;

    return [
      `M ${p1.x} ${p1.y}`,
      `A ${rOuter} ${rOuter} 0 ${largeArc} 1 ${p2.x} ${p2.y}`,
      `L ${p3.x} ${p3.y}`,
      `A ${rInner} ${rInner} 0 ${largeArc} 0 ${p4.x} ${p4.y}`,
      'Z'
    ].join(' ');
  }

  // Keep text upright-ish: if angle is on the bottom half, rotate 180Â°.
  function uprightTextRotation(angleDeg) {
    const a = ((angleDeg % 360) + 360) % 360;
    return (a > 90 && a < 270) ? 180 : 0;
  }

  /**
   * ==========================================================
   * Wheel building
   * ==========================================================
   *
   * Radii (outer -> inner):
   *   Slot ring: 240..280
   *   Ring A:    195..235
   *   Ring B:    150..190
   *   Ring C:    105..145
   */
  const RAD = {
    slotIn: 240, slotOut: 280,
    aIn: 195, aOut: 235,
    bIn: 150, bOut: 190,
    cIn: 105, cOut: 145,
  };

  function clearGroup(g) { while (g.firstChild) g.removeChild(g.firstChild); }

  /**
   * Build outer slot ring: fixed wedges with slot numbers, clickable.
   */
  function buildSlotRing() {
    clearGroup(el.slotRing);

    for (let slot = 1; slot <= SLOTS; slot++) {
      const start = (slot - 1) * STEP_DEG;
      const end = slot * STEP_DEG;

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.classList.add('slotWedge');
      g.dataset.slot = String(slot);

      const isHouse = UNBETTABLE.has(slot);
      if (isHouse) g.classList.add('house');

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', wedgePath(RAD.slotIn, RAD.slotOut, start, end));

      // Bettable vs house styling
      if (isHouse) {
        path.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--houseFill') || 'rgba(255,208,122,0.22)');
        path.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--houseStroke') || 'rgba(255,208,122,0.55)');
      } else {
        path.setAttribute('fill', 'rgba(0,0,0,0.16)');
        path.setAttribute('stroke', 'rgba(120,255,160,0.16)');
      }
      path.setAttribute('stroke-width', '1.2');

      // Slot number text at mid-angle
      const mid = start + STEP_DEG / 2;
      const pos = polar(CX, CY, (RAD.slotIn + RAD.slotOut) / 2, mid);

      const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      txt.classList.add('slotText');
      if (isHouse) txt.classList.add('house');
      txt.setAttribute('x', pos.x);
      txt.setAttribute('y', pos.y);
      txt.setAttribute('text-anchor', 'middle');
      txt.setAttribute('dominant-baseline', 'middle');
      txt.textContent = String(slot);

      // rotate text slightly to follow ring; flip on bottom half
      const flip = uprightTextRotation(mid);
      txt.setAttribute('transform', `rotate(${mid + flip} ${pos.x} ${pos.y})`);

      if (!isHouse) {
        g.addEventListener('click', () => toggleSlot(slot));
      }

      g.appendChild(path);
      g.appendChild(txt);
      el.slotRing.appendChild(g);
    }
  }

  /**
   * Build a symbol ring inside the wheel.
   * - The ring itself is a rotating <g>.
   * - Each sector is a wedge with a glyph text placed at its center.
   */
  function buildSymbolRing(groupEl, ringSymbols, rInner, rOuter) {
    clearGroup(groupEl);

    for (let i = 0; i < SLOTS; i++) {
      const slot = i + 1;
      const start = i * STEP_DEG;
      const end = (i + 1) * STEP_DEG;
      const mid = start + STEP_DEG / 2;

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.dataset.slot = String(slot);

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', wedgePath(rInner, rOuter, start, end));
      path.setAttribute('fill', 'rgba(0,0,0,0.18)');
      path.setAttribute('stroke', 'rgba(120,255,160,0.12)');
      path.setAttribute('stroke-width', '1.0');

      const sym = ringSymbols[i];
      const glyph = GLYPH[sym] ?? sym[0];

      const pos = polar(CX, CY, (rInner + rOuter) / 2, mid);
      const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      txt.classList.add('symbolGlyph');
      txt.setAttribute('x', pos.x);
      txt.setAttribute('y', pos.y);
      txt.setAttribute('text-anchor', 'middle');
      txt.setAttribute('dominant-baseline', 'middle');
      txt.textContent = glyph;

      // Keep glyph roughly upright
      const flip = uprightTextRotation(mid);
      txt.setAttribute('transform', `rotate(${mid + flip} ${pos.x} ${pos.y})`);

      g.appendChild(path);
      g.appendChild(txt);
      groupEl.appendChild(g);
    }
  }

  /**
   * Update selection highlight on the outer slot ring.
   */
  function syncSelectionUI() {
    // Slot wedge selected styling
    const wedges = el.slotRing.querySelectorAll('g.slotWedge');
    wedges.forEach(w => {
      const slot = Number(w.dataset.slot);
      w.classList.toggle('selected', state.selected.includes(slot));
    });

    // Chips list
    renderChips();
  }

  function renderChips() {
    el.chips.innerHTML = '';
    if (state.selected.length === 0) {
      el.slotsHint.textContent = 'No slots selected.';
      return;
    }
    el.slotsHint.textContent = `Selected: ${state.selected.join(', ')}`;

    for (const slot of state.selected) {
      const chip = document.createElement('div');
      chip.className = 'chip';
      chip.innerHTML = `SLOT ${slot} <button title="Remove slot ${slot}">Ã—</button>`;
      chip.querySelector('button').addEventListener('click', () => {
        state.selected = state.selected.filter(s => s !== slot);
        syncSelectionUI();
      });
      el.chips.appendChild(chip);
    }
  }

  function toggleSlot(slot) {
    if (state.spinning) return;
    if (UNBETTABLE.has(slot)) return;

    if (state.selected.includes(slot)) {
      state.selected = state.selected.filter(s => s !== slot);
    } else {
      if (state.selected.length >= 3) return;
      state.selected = [...state.selected, slot].sort((a,b)=>a-b);
    }
    syncSelectionUI();
  }

  function clearSelection() {
    state.selected = [];
    syncSelectionUI();
  }

  /**
   * ==========================================================
   * Rotation + animation
   * ==========================================================
   *
   * We rotate SVG groups with transform="rotate(angle cx cy)".
   * Positive angle rotates clockwise in SVG; we spin CCW by decreasing degrees.
   */

  function setGroupRotation(groupEl, deg) {
    groupEl.setAttribute('transform', `rotate(${deg} ${CX} ${CY})`);
  }

  function mod(n, m) { return ((n % m) + m) % m; }

  // Ease-out curve for deceleration.
  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  /**
   * Compute a target degree that:
   *  - ends at targetPhaseDeg modulo 360
   *  - moves in the negative direction (CCW spin)
   *  - includes several extra revolutions (for drama)
   */
  function computeTargetDeg(currentDeg, targetPhaseDeg, extraRevs) {
    const curPhase = mod(currentDeg, 360);
    const tgtPhase = mod(targetPhaseDeg, 360);

    // phaseDelta in (-360, 0] for CCW-only travel
    let phaseDelta = tgtPhase - curPhase;
    phaseDelta = mod(phaseDelta, 360);
    if (phaseDelta > 0) phaseDelta -= 360;

    // additional full spins (negative)
    return currentDeg + phaseDelta - (extraRevs * 360);
  }

  /**
   * Ring animation object: cruise then decel.
   */
  function makeAnim(getDeg, setDeg) {
    return {
      phase: 'idle',
      getDeg, setDeg,
      vel: 0, // deg/sec (negative for CCW)
      decelStartDeg: 0,
      decelEndDeg: 0,
      decelStartMs: 0,
      decelDurMs: 0,
    };
  }

  const animA = makeAnim(() => state.rotA, (d) => { state.rotA = d; setGroupRotation(el.ringA, d); });
  const animB = makeAnim(() => state.rotB, (d) => { state.rotB = d; setGroupRotation(el.ringB, d); });
  const animC = makeAnim(() => state.rotC, (d) => { state.rotC = d; setGroupRotation(el.ringC, d); });

  function startDecel(anim, nowMs, endDeg, durMs) {
    anim.phase = 'decel';
    anim.decelStartDeg = anim.getDeg();
    anim.decelEndDeg = endDeg;
    anim.decelStartMs = nowMs;
    anim.decelDurMs = durMs;
    anim.vel = 0;
  }

  let rafId = 0;

  function runUntilStop() {
    return new Promise(resolve => {
      const last = { t: performance.now() };

      function tick(now) {
        const dt = (now - last.t) / 1000;
        last.t = now;

        const rings = [animA, animB, animC];

        for (const a of rings) {
          if (a.phase === 'cruise') {
            a.setDeg(a.getDeg() + a.vel * dt);
          } else if (a.phase === 'decel') {
            const t = Math.min(1, (now - a.decelStartMs) / a.decelDurMs);
            const e = easeOutCubic(t);
            a.setDeg(a.decelStartDeg + (a.decelEndDeg - a.decelStartDeg) * e);
            if (t >= 1) a.phase = 'stopped';
          }
        }

        const anyMoving = rings.some(a => a.phase === 'cruise' || a.phase === 'decel');
        if (anyMoving) rafId = requestAnimationFrame(tick);
        else resolve();
      }

      rafId = requestAnimationFrame(tick);
    });
  }

  /**
   * ==========================================================
   * Results rendering
   * ==========================================================
   */
  function renderResults(rows) {
    el.resultsBody.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.slot}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sa] ?? r.sa}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sb] ?? r.sb}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sc] ?? r.sc}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.match}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.mult}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.win}</td>
      `;
      el.resultsBody.appendChild(tr);
    }
    el.resultsTable.style.display = '';
  }

  /**
   * ==========================================================
   * Spin orchestration
   * ==========================================================
   */
  async function spin() {
    if (state.spinning) return;

    if (state.selected.length < 1 || state.selected.length > 3) {
      setStatus('ERROR // SELECT 1â€“3 BETTABLE SLOTS', 'bad');
      return;
    }

    const vb = validateBet(state.selected.length);
    if (!vb.ok) {
      setStatus(`ERROR // ${vb.reason}`, 'bad');
      return;
    }
    const bet = vb.bet;

    // Stake immediately.
    const stake = bet * state.selected.length;
    state.bankroll -= stake;
    updateBankroll();

    setSpinning(true);
    setStatus('SPINNING // WATCH THE WHEEL', 'warn');
    el.spinMeta.textContent = '';
    el.resultsTable.style.display = 'none';

    // Choose final offsets per ring (0..35).
    const final = {
      a: randInt(0, SLOTS),
      b: randInt(0, SLOTS),
      c: randInt(0, SLOTS),
    };

    // Desired final phase degrees for each ring:
    // angle = -offset * 10Â° (CCW) to match symbolAtSlot mapping.
    const targetPhaseA = -final.a * STEP_DEG;
    const targetPhaseB = -final.b * STEP_DEG;
    const targetPhaseC = -final.c * STEP_DEG;

    if (prefersReducedMotion()) {
      // Snap directly to phases.
      state.rotA = targetPhaseA; state.rotB = targetPhaseB; state.rotC = targetPhaseC;
      setGroupRotation(el.ringA, state.rotA);
      setGroupRotation(el.ringB, state.rotB);
      setGroupRotation(el.ringC, state.rotC);
      animA.phase = animB.phase = animC.phase = 'stopped';
    } else {
      // Cruise speeds (deg/sec), negative for CCW.
      animA.phase = 'cruise'; animA.vel = -randInt(220, 300);
      animB.phase = 'cruise'; animB.vel = -randInt(260, 340);
      animC.phase = 'cruise'; animC.vel = -randInt(300, 420);

      // Compute deterministic end degrees with extra revolutions.
      const endA = computeTargetDeg(state.rotA, targetPhaseA, randInt(5, 9));
      const endB = computeTargetDeg(state.rotB, targetPhaseB, randInt(6, 10));
      const endC = computeTargetDeg(state.rotC, targetPhaseC, randInt(7, 11));

      // Start the animation loop.
      const loop = runUntilStop();

      // Sequential stop timings: A then B then C (like a physical wheel settling).
      setTimeout(() => startDecel(animA, performance.now(), endA, randInt(900, 1400)), randInt(700, 1000));
      setTimeout(() => startDecel(animB, performance.now(), endB, randInt(950, 1500)), randInt(950, 1250));
      setTimeout(() => startDecel(animC, performance.now(), endC, randInt(1000, 1600)), randInt(1200, 1500));

      await loop;

      // Snap exactly to final phases after stop (guards against float drift).
      state.rotA = targetPhaseA;
      state.rotB = targetPhaseB;
      state.rotC = targetPhaseC;
      setGroupRotation(el.ringA, state.rotA);
      setGroupRotation(el.ringB, state.rotB);
      setGroupRotation(el.ringC, state.rotC);
    }

    // Evaluate results from final offsets (not from degrees).
    const rows = [];
    let totalWin = 0;

    for (const slot of state.selected) {
      const [sa, sb, sc] = symbolsAtSlot(slot, final);
      const mult = payoutMultiplier([sa, sb, sc]);
      const win = bet * mult;
      totalWin += win;
      rows.push({ slot, sa, sb, sc, mult, win, match: matchLabel(mult) });
    }

    state.bankroll += totalWin;
    updateBankroll();

    el.spinMeta.textContent =
      `Offsets: A=${final.a}, B=${final.b}, C=${final.c} â€” Staked ${stake}, Won ${totalWin}, Net ${totalWin - stake}`;
    renderResults(rows);

    if (totalWin > 0) setStatus('DABO! // PROFIT ACHIEVED', 'ok');
    else setStatus('NO HIT // REASSESS YOUR STRATEGY', 'muted');

    if (state.bankroll < MIN_BET) {
      setStatus('INSUFFICIENT FUNDS // RESET REQUIRED', 'bad');
      el.spinBtn.disabled = true;
    }

    setSpinning(false);
  }

  function resetAll() {
    cancelAnimationFrame(rafId);

    state.bankroll = 1000;
    updateBankroll();

    // Reset rotations to 0.
    state.rotA = 0; state.rotB = 0; state.rotC = 0;
    setGroupRotation(el.ringA, 0);
    setGroupRotation(el.ringB, 0);
    setGroupRotation(el.ringC, 0);

    animA.phase = animB.phase = animC.phase = 'idle';

    clearSelection();

    el.betInput.value = '';
    el.betHint.textContent = '';
    el.spinMeta.textContent = '';
    el.resultsTable.style.display = 'none';

    el.spinBtn.disabled = false;
    setStatus('SELECT SLOTS, ENTER BET, THEN SPIN.', 'muted');
  }

  /**
   * ==========================================================
   * Init
   * ==========================================================
   */
  function init() {
    buildSlotRing();
    buildSymbolRing(el.ringA, RING_A, RAD.aIn, RAD.aOut);
    buildSymbolRing(el.ringB, RING_B, RAD.bIn, RAD.bOut);
    buildSymbolRing(el.ringC, RING_C, RAD.cIn, RAD.cOut);

    // Initial rotations
    setGroupRotation(el.ringA, state.rotA);
    setGroupRotation(el.ringB, state.rotB);
    setGroupRotation(el.ringC, state.rotC);

    updateBankroll();
    clearSelection();
    setStatus('SELECT SLOTS, ENTER BET, THEN SPIN.', 'muted');

    el.spinBtn.addEventListener('click', spin);
    el.clearBtn.addEventListener('click', () => { clearSelection(); setStatus('SELECTION CLEARED.', 'muted'); });
    el.resetBtn.addEventListener('click', resetAll);

    el.betInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') spin();
    });
    el.betInput.addEventListener('input', () => {
      if (state.selected.length > 0) validateBet(state.selected.length);
    });

    // If the user zooms/resizes, SVG scales automatically.
    // We only need to re-sync selection UI (safe and cheap).
    window.addEventListener('resize', () => syncSelectionUI(), { passive: true });
  }

  init();
})();
</script>
</body>
</html>