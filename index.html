<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DABO // Ferengi Wheel</title>

  <!--
    ==========================================================
    DABO â€” Ferengi Wheel (Single-file static app)
    ==========================================================
    This file intentionally contains *everything*: CSS + SVG + JS.

    Key features:
      - Top-down SVG wheel: outer slot ring (clickable), 3 rotating symbol rings, fixed pointer.
      - Reserved/house-only slots: RED shaded + high-contrast numbers, disabled from selection.
      - Result modal dialog after each spin: summary + Quark jape + big ASCII Quark + OK.
      - Responsive hardening (portrait/mobile): avoids letter-by-letter wrapping, uses clamp + breakpoints.
      - Reduced motion: snaps results if prefers-reduced-motion is set.

    Math/logic mapping:
      - 36 slots => 10Â° per slot
      - Each ring has an integer offset in [0..35]
      - For slot N (1-based): symbol = ring[(N-1 + offset) % 36]
      - To match visually, ring group rotates CCW by offset*10Â° => angle = -offset*10Â°
  -->

  <style>
    :root{
      --bg0:#060707;
      --bg1:#0a0c0b;

      --ink:#b7ffbf;
      --ink2:#7bff8f;
      --warn:#ffd07a;
      --bad:#ff7a7a;

      --brass2:#d2a84b;
      --brass3:#f7d57e;

      /* Reserved / house-only slots (RED shading) */
      --reservedFill: rgba(255, 80, 80, 0.24);
      --reservedStroke: rgba(255, 90, 90, 0.70);
      --reservedText: rgba(255, 245, 245, 0.98);

      /* Layout */
      --radius: 16px;
      --gap: clamp(10px, 2.2vw, 16px);
      --wheelMax: 680px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: var(--ink);
      background:
        radial-gradient(1000px 700px at 20% 0%, rgba(90,180,120,0.10), transparent 55%),
        radial-gradient(800px 600px at 70% 20%, rgba(210,168,75,0.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* IMPORTANT:
       - We avoid overflow-wrap:anywhere globally because it can cause letter-by-letter breaks on narrow screens.
       - Instead we apply safe wrapping to only the elements that need it, and use break-word (not anywhere). */
    .wrap{ max-width: 1120px; margin: 22px auto; padding: 0 16px 40px; }

    .frame{
      border-radius: 26px;
      padding: 14px;
      background:
        linear-gradient(135deg, rgba(210,168,75,0.25), rgba(210,168,75,0.06) 35%, rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(30, 18, 4, 0.65), rgba(10, 8, 5, 0.75));
      box-shadow:
        0 18px 70px rgba(0,0,0,0.6),
        inset 0 0 0 1px rgba(247,213,126,0.18);
    }

    .terminal{
      position:relative;
      border-radius: 18px;
      padding: clamp(14px, 2vw, 18px);
      background: linear-gradient(180deg, rgba(10,24,18,0.92), rgba(6,12,9,0.92));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.12),
        inset 0 0 40px rgba(0,0,0,0.6);
      overflow:hidden;
    }

    /* CRT scanlines */
    .terminal:before{
      content:"";
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.05) 0px,
        rgba(255,255,255,0.03) 1px,
        rgba(0,0,0,0.00) 2px,
        rgba(0,0,0,0.00) 5px
      );
      opacity:0.10;
      pointer-events:none;
    }

    .topbar{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 14px;
      position:relative;
      z-index:2;
    }

    .title{
      display:flex;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
      min-width: 0;
      text-shadow: 0 0 10px rgba(120,255,160,0.25);
    }
    .title h1{
      margin:0;
      font-weight: 900;
      letter-spacing: 0.10em;
      font-size: clamp(18px, 2.1vw, 24px);
      white-space: nowrap;
    }
    .subtitle{
      font-size: 12px;
      letter-spacing: 0.09em;
      color: rgba(183,255,191,0.75);
      max-width: 100%;
      word-break: normal;
      overflow-wrap: break-word;
    }

    .statusrow{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
      min-width: 0;
    }

    .pill{
      display:inline-flex;
      gap: 10px;
      align-items: center;
      padding: 8px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(120,255,160,0.10), rgba(120,255,160,0.04));
      box-shadow: inset 0 0 0 1px rgba(120,255,160,0.16);
      font-size: 12px;
      letter-spacing: 0.06em;
      user-select:none;

      /* Desktop flow stays clean */
      white-space: nowrap;

      /* Avoid mid-letter breaks */
      word-break: normal;
      overflow-wrap: normal;
      min-width: 0;
      max-width: 100%;
    }
    .pillBrass{
      background: linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow: inset 0 0 0 1px rgba(210,168,75,0.28);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: var(--gap);
      min-width: 0;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: var(--radius);
      padding: 14px;
      background: linear-gradient(180deg, rgba(10,22,16,0.80), rgba(8,14,11,0.82));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.10),
        0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      min-width: 0;
    }

    .panel h2{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(183,255,191,0.82);
    }

    .muted{
      color: rgba(183,255,191,0.68);
      font-size: 12px;
      line-height: 1.4;
      word-break: normal;
      overflow-wrap: break-word;
    }
    .monoSmall{
      font-size: 11px;
      letter-spacing:0.10em;
      color: rgba(183,255,191,0.82);
      word-break: normal;
      overflow-wrap: break-word;
    }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }
    .ok{ color: var(--ink2); }

    label{
      display:block;
      margin: 10px 0 6px;
      font-size: 12px;
      letter-spacing:0.08em;
      color: rgba(183,255,191,0.85);
    }
    input, button{
      font: inherit;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(120,255,160,0.18);
      background: rgba(0,0,0,0.25);
      color: var(--ink);
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
      min-width: 0;
      max-width: 100%;
    }
    input::placeholder{ color: rgba(183,255,191,0.35); }
    button{
      cursor:pointer;
      border-color: rgba(210,168,75,0.35);
      background: linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 8px 18px rgba(0,0,0,0.35);
      letter-spacing:0.10em;
      text-transform: uppercase;
      font-weight: 900;
      white-space: nowrap;
    }
    button:disabled{ cursor:not-allowed; opacity:0.55; filter: saturate(0.7); }

    .ctaRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 8px;
      min-height: 28px;
      min-width: 0;
    }
    .chip{
      display:inline-flex;
      gap: 8px;
      align-items:center;
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(210,168,75,0.10);
      border: 1px solid rgba(210,168,75,0.28);
      color: rgba(247,213,126,0.95);
      font-size: 11px;
      letter-spacing:0.08em;
      user-select:none;
      max-width: 100%;
      overflow-wrap: break-word;
    }
    .chip button{
      all: unset;
      cursor:pointer;
      font-weight: 900;
      padding: 0 6px;
      border-radius: 999px;
      color: rgba(247,213,126,0.95);
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(210,168,75,0.25);
    }

    /* Wheel container: stays circular and scales responsibly */
    .wheelShell{
      display:grid;
      place-items:center;
      width: 100%;
      max-width: var(--wheelMax);
      margin: 10px auto 0;
      aspect-ratio: 1;
      min-width: 0;
    }
    svg#wheelSvg{
      width: 100%;
      height: 100%;
      display:block;
      touch-action: manipulation;
      user-select:none;
    }

    /* SVG styling */
    .slotWedge{ cursor:pointer; }
    .slotWedge.house{ cursor:not-allowed; }

    .slotText{
      font-size: 14px;
      fill: rgba(183,255,191,0.85);
      paint-order: stroke;
      stroke: rgba(0,0,0,0.55);
      stroke-width: 3px;
      stroke-linejoin: round;
      user-select:none;
    }
    .slotText.house{
      fill: var(--reservedText);
      stroke: rgba(0,0,0,0.65);
    }

    .slotWedge.selected path{
      stroke: rgba(247,213,126,0.75) !important;
      stroke-width: 2.5 !important;
      filter: drop-shadow(0 0 10px rgba(247,213,126,0.18));
    }

    .symbolGlyph{
      font-size: 18px;
      fill: rgba(183,255,191,0.92);
      paint-order: stroke;
      stroke: rgba(0,0,0,0.55);
      stroke-width: 3px;
      stroke-linejoin: round;
      user-select:none;
    }

    /* ===========================
       Modal dialog (Quark jape)
       =========================== */
    .modal.hidden{ display:none; }
    .modal{
      position:fixed;
      inset:0;
      z-index:9999;
      display:grid;
      place-items:center;
      padding: clamp(10px, 3vw, 20px);
    }
    .modalBackdrop{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(2px);
    }
    .modalPanel{
      position:relative;
      width:min(980px, 100%);
      max-height:min(86vh, 820px);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(10,24,18,0.96), rgba(6,12,9,0.96));
      box-shadow:
        0 18px 70px rgba(0,0,0,0.7),
        inset 0 0 0 1px rgba(247,213,126,0.24),
        inset 0 0 40px rgba(0,0,0,0.55);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-width:0;
    }
    .modalHeader{
      padding: 14px 14px 10px;
      border-bottom: 1px solid rgba(120,255,160,0.12);
      display:flex;
      flex-direction:column;
      gap: 6px;
    }
    .modalTitle{
      font-weight: 900;
      letter-spacing: 0.14em;
      font-size: clamp(14px, 2.1vw, 18px);
      color: rgba(247,213,126,0.96);
    }
    .modalSub{
      font-size: 12px;
      letter-spacing: 0.08em;
      color: rgba(183,255,191,0.74);
      overflow-wrap: break-word;
    }

    .modalBody{
      padding: 14px;
      display:grid;
      grid-template-columns: 1fr 1.2fr;
      gap: 12px;
      min-width:0;
      overflow:auto;
    }
    .ascii{
      margin:0;
      padding: 12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(210,168,75,0.22);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
      color: rgba(247,213,126,0.95);

      /* Big and readable; clamps down for tiny screens */
      font-size: clamp(10px, 1.7vw, 14px);
      line-height: 1.05;

      /* Keep ASCII intact; allow scrolling rather than mangling */
      white-space: pre;
      overflow: auto;
      max-width: 100%;
    }
    .modalCopy{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .modalSummary{
      padding: 12px;
      border-radius: 14px;
      background: rgba(120,255,160,0.06);
      border: 1px solid rgba(120,255,160,0.14);
      overflow-wrap: break-word;
    }
    .modalRemark{
      padding: 12px;
      border-radius: 14px;
      background: rgba(210,168,75,0.10);
      border: 1px solid rgba(210,168,75,0.22);
      color: rgba(247,213,126,0.95);
      overflow-wrap: break-word;
    }
    .modalFooter{
      padding: 12px 14px 14px;
      border-top: 1px solid rgba(120,255,160,0.12);
      display:flex;
      justify-content:flex-end;
      gap: 10px;
    }
    .modalOk{ }

    /* Portrait/mobile breakpoints: fix wrapping WITHOUT hurting desktop */
    @media (max-width: 520px){
      .statusrow{ justify-content:flex-start; }
      .pill{
        white-space: normal;           /* allow wrap on small screens */
        letter-spacing: 0.05em;
      }
      .title{ gap: 6px; }
      .title h1{ letter-spacing: 0.08em; }
      .subtitle{ letter-spacing: 0.05em; }
      .modalBody{ grid-template-columns: 1fr; }
      .ascii{ font-size: clamp(10px, 3.2vw, 13px); }
    }

    /* Short-height devices (landscape phones) */
    @media (max-height: 560px){
      .modalPanel{ max-height: 92vh; }
      .modalBody{ padding: 10px; }
    }

    @media (prefers-reduced-motion: reduce){
      .modalBackdrop{ backdrop-filter: none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="frame">
      <div class="terminal">

        <div class="topbar">
          <div class="title">
            <h1>DABO</h1>
            <div class="subtitle">TOP-DOWN WHEEL // FERENGI GAMING TERMINAL</div>
          </div>
          <div class="statusrow">
            <div class="pill pillBrass">LATINUM: <strong id="bankrollVal">1000</strong></div>
            <div class="pill">PAYOUT: <strong>Q+ðŸŒ€+ðŸŒ€</strong>=4000Ã— â€¢ <strong>3K</strong>=100Ã— â€¢ <strong>2K</strong>=5Ã—</div>
          </div>
        </div>

        <div class="grid">
          <div class="panel">
            <h2>Wheel</h2>

            <div class="muted" id="hintLine">
              Tap/click slot numbers to select (1â€“3). Reserved slots are shaded red and disabled.
            </div>

            <div class="wheelShell" aria-label="Dabo wheel">
              <svg id="wheelSvg" viewBox="0 0 600 600" role="img" aria-label="Dabo wheel">
                <defs>
                  <radialGradient id="wheelGlow" cx="50%" cy="45%" r="60%">
                    <stop offset="0%" stop-color="rgba(120,255,160,0.08)"/>
                    <stop offset="60%" stop-color="rgba(0,0,0,0)"/>
                  </radialGradient>
                </defs>
                <rect x="0" y="0" width="600" height="600" fill="url(#wheelGlow)"></rect>

                <!-- Outer rim -->
                <circle cx="300" cy="300" r="285" fill="rgba(0,0,0,0.18)" stroke="rgba(247,213,126,0.22)" stroke-width="3"></circle>

                <!-- Slot ring (fixed, clickable) -->
                <g id="slotRing"></g>

                <!-- Rotating symbol rings -->
                <g id="ringA"></g>
                <g id="ringB"></g>
                <g id="ringC"></g>

                <!-- Hub -->
                <circle cx="300" cy="300" r="70" fill="rgba(0,0,0,0.35)" stroke="rgba(120,255,160,0.14)" stroke-width="2"></circle>
                <text x="300" y="305" text-anchor="middle" class="symbolGlyph" style="font-size:20px; letter-spacing:0.18em;">DABO</text>

                <!-- Pointer at top -->
                <polygon points="300,18 290,38 310,38" fill="rgba(247,213,126,0.85)" stroke="rgba(0,0,0,0.6)" stroke-width="2"></polygon>
              </svg>
            </div>

            <div style="margin-top:12px;">
              <div id="statusLine" class="monoSmall">SELECT SLOTS, ENTER BET, THEN SPIN.</div>
              <div id="spinMeta" class="muted" style="margin-top:8px;"></div>

              <table id="resultsTable" style="display:none; width:100%; border-collapse:collapse; margin-top:10px; font-size:12px;">
                <thead>
                  <tr>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Slot</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">A</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">B</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">C</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Match</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Mult</th>
                    <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">Win</th>
                  </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
              </table>
            </div>
          </div>

          <div class="panel">
            <h2>Controls</h2>

            <label>SELECTED SLOTS</label>
            <div class="chips" id="chips"></div>
            <div id="slotsHint" class="muted"></div>

            <label for="betInput">BET PER SLOT</label>
            <input id="betInput" placeholder="10" autocomplete="off" inputmode="numeric" />
            <div id="betHint" class="muted" style="margin-top:6px;"></div>

            <div class="ctaRow" style="margin-top:12px;">
              <button id="spinBtn">Spin</button>
              <button id="clearBtn">Clear</button>
              <button id="resetBtn">Reset</button>
            </div>

            <div class="muted" style="margin-top: 14px;">
              Reduce Motion enabled? The wheel snaps to results.
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Result modal (Quark terminal dialog) -->
  <div id="resultModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modalBackdrop" data-close="1"></div>
    <div class="modalPanel" tabindex="-1">
      <div class="modalHeader">
        <div id="modalTitle" class="modalTitle">RESULT</div>
        <div id="modalSub" class="modalSub">Quarkâ€™s assessment pendingâ€¦</div>
      </div>
      <div class="modalBody">
        <pre id="quarkAscii" class="ascii" aria-label="ASCII art of Quark"></pre>
        <div class="modalCopy">
          <div id="modalSummary" class="modalSummary"></div>
          <div id="modalRemark" class="modalRemark"></div>
        </div>
      </div>
      <div class="modalFooter">
        <button id="modalOk" class="modalOk">OK</button>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  /**
   * ==========================================================
   * Constants / configuration
   * ==========================================================
   */
  const SLOTS = 36;
  const STEP_DEG = 360 / SLOTS; // 10 degrees per slot
  const MIN_BET = 10;
  const MAX_BET = 100;

  // Reserved / house-only slots: unbettable and shaded RED in the UI.
  const RESERVED = new Set([5,6,7,17,18,19,29,30,31]);

  // Symbols (logic) and glyphs (presentation).
  const SYMBOLS = {
    BAR: 'BAR',
    ORB: 'ORB',
    COMET: 'COMET',
    BOLT: 'BOLT',
    MOON: 'MOON',
    SUN: 'SUN',
    SWIRL: 'SWIRL',
    DS9: 'DS9',
    QUARK: 'QUARK',
  };

  // Simple glyphs for cross-platform reliability.
  const GLYPH = {
    BAR: 'â–®â–®',
    ORB: 'â—',
    COMET: 'â˜„',
    BOLT: 'âš¡',
    MOON: 'â˜¾',
    SUN:  'â˜‰',
    SWIRL:'ðŸŒ€',
    DS9:  'â¬¡',
    QUARK:'Q',
  };

  const COMMON_PATTERN = [
    SYMBOLS.BAR, SYMBOLS.ORB, SYMBOLS.COMET, SYMBOLS.BOLT,
    SYMBOLS.MOON, SYMBOLS.SUN, SYMBOLS.BOLT, SYMBOLS.ORB,
  ];

  function buildRing(seedShift = 0) {
    const ring = Array.from({ length: SLOTS }, (_, i) => COMMON_PATTERN[(i + seedShift) % COMMON_PATTERN.length]);

    // Specials (1-based placements)
    ring[17 - 1] = SYMBOLS.QUARK;
    ring[8  - 1] = SYMBOLS.SWIRL;
    ring[28 - 1] = SYMBOLS.SWIRL;
    ring[11 - 1] = SYMBOLS.DS9;
    ring[22 - 1] = SYMBOLS.DS9;
    ring[34 - 1] = SYMBOLS.DS9;

    return ring;
  }

  const RING_A = buildRing(0);
  const RING_B = buildRing(3);
  const RING_C = buildRing(5);

  /**
   * ==========================================================
   * Randomness utilities
   * ==========================================================
   * Use WebCrypto when available; fall back to Math.random.
   */
  function randInt(minInclusive, maxExclusive) {
    const range = maxExclusive - minInclusive;
    if (range <= 0) return minInclusive;

    try {
      if (globalThis.crypto?.getRandomValues) {
        const maxUint = 0xFFFFFFFF;
        const limit = maxUint - (maxUint % range);
        const buf = new Uint32Array(1);
        let x;
        do {
          globalThis.crypto.getRandomValues(buf);
          x = buf[0];
        } while (x >= limit);
        return minInclusive + (x % range);
      }
    } catch (_) {}
    return minInclusive + Math.floor(Math.random() * range);
  }

  function prefersReducedMotion() {
    return globalThis.matchMedia && globalThis.matchMedia('(prefers-reduced-motion: reduce)').matches;
  }

  /**
   * ==========================================================
   * DOM bindings
   * ==========================================================
   */
  const el = {
    bankrollVal: document.getElementById('bankrollVal'),
    betInput: document.getElementById('betInput'),
    betHint: document.getElementById('betHint'),
    slotsHint: document.getElementById('slotsHint'),
    chips: document.getElementById('chips'),

    statusLine: document.getElementById('statusLine'),
    spinMeta: document.getElementById('spinMeta'),

    resultsTable: document.getElementById('resultsTable'),
    resultsBody: document.getElementById('resultsBody'),

    spinBtn: document.getElementById('spinBtn'),
    clearBtn: document.getElementById('clearBtn'),
    resetBtn: document.getElementById('resetBtn'),

    slotRing: document.getElementById('slotRing'),
    ringA: document.getElementById('ringA'),
    ringB: document.getElementById('ringB'),
    ringC: document.getElementById('ringC'),

    // Modal
    modal: document.getElementById('resultModal'),
    modalBackdrop: document.querySelector('#resultModal .modalBackdrop'),
    modalPanel: document.querySelector('#resultModal .modalPanel'),
    modalTitle: document.getElementById('modalTitle'),
    modalSub: document.getElementById('modalSub'),
    modalSummary: document.getElementById('modalSummary'),
    modalRemark: document.getElementById('modalRemark'),
    quarkAscii: document.getElementById('quarkAscii'),
    modalOk: document.getElementById('modalOk'),
  };

  /**
   * ==========================================================
   * State
   * ==========================================================
   */
  const state = {
    bankroll: 1000,
    selected: [],   // 1-based slot numbers (max 3)
    spinning: false,

    // Rotation degrees for each symbol ring (unwrapped).
    rotA: 0,
    rotB: 0,
    rotC: 0,

    // For focus restore after modal
    lastFocusEl: null,
  };

  function setStatus(msg, kind='muted') {
    el.statusLine.className = `monoSmall ${kind}`;
    el.statusLine.textContent = msg;
  }

  function updateBankroll() {
    el.bankrollVal.textContent = String(state.bankroll);
  }

  function setSpinning(on) {
    state.spinning = on;
    el.spinBtn.disabled = on;
    el.clearBtn.disabled = on;
    el.resetBtn.disabled = on;
    el.betInput.disabled = on;
  }

  /**
   * ==========================================================
   * Bet validation
   * ==========================================================
   */
  function validateBet(slotsCount) {
    const betRaw = el.betInput.value.trim();
    const bet = betRaw === '' ? MIN_BET : Number(betRaw);

    if (!Number.isInteger(bet)) {
      el.betHint.textContent = 'Bet must be a whole number.';
      return { ok:false, reason:'INVALID BET' };
    }

    const maxAffordablePerSlot = Math.floor(state.bankroll / Math.max(1, slotsCount));
    const effectiveMax = Math.min(MAX_BET, maxAffordablePerSlot);

    if (bet < MIN_BET || bet > effectiveMax) {
      el.betHint.textContent = `Bet per slot must be ${MIN_BET}â€“${effectiveMax} (based on bankroll).`;
      return { ok:false, reason:'BET OUT OF RANGE' };
    }

    el.betHint.textContent = `Total stake: ${bet * slotsCount}.`;
    return { ok:true, bet };
  }

  /**
   * ==========================================================
   * Payout rules
   * ==========================================================
   */
  function payoutMultiplier([sa, sb, sc]) {
    const trio = [sa, sb, sc].slice().sort().join('|');
    const jackpot = [SYMBOLS.QUARK, SYMBOLS.SWIRL, SYMBOLS.SWIRL].slice().sort().join('|');

    if (trio === jackpot) return 4000;
    if (sa === sb && sb === sc) return 100;
    if (sa === sb || sa === sc || sb === sc) return 5;
    return 0;
  }

  function matchLabel(mult) {
    if (mult === 4000) return 'JACK';
    if (mult === 100) return '3K';
    if (mult === 5) return '2K';
    return '--';
  }

  function symbolsAtSlot(slot1Based, offsets) {
    const i = (slot1Based - 1) % SLOTS;
    const sa = RING_A[(i + offsets.a) % SLOTS];
    const sb = RING_B[(i + offsets.b) % SLOTS];
    const sc = RING_C[(i + offsets.c) % SLOTS];
    return [sa, sb, sc];
  }

  /**
   * ==========================================================
   * SVG geometry helpers
   * ==========================================================
   */
  const CX = 300, CY = 300;

  function degToRad(d) { return (d * Math.PI) / 180; }

  // Angle 0Â° points "up" (12 o'clock) due to subtracting 90Â°.
  function polar(cx, cy, r, angleDeg) {
    const a = degToRad(angleDeg - 90);
    return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
  }

  function wedgePath(rInner, rOuter, startDeg, endDeg) {
    const p1 = polar(CX, CY, rOuter, startDeg);
    const p2 = polar(CX, CY, rOuter, endDeg);
    const p3 = polar(CX, CY, rInner, endDeg);
    const p4 = polar(CX, CY, rInner, startDeg);

    const largeArc = (endDeg - startDeg) > 180 ? 1 : 0;

    return [
      `M ${p1.x} ${p1.y}`,
      `A ${rOuter} ${rOuter} 0 ${largeArc} 1 ${p2.x} ${p2.y}`,
      `L ${p3.x} ${p3.y}`,
      `A ${rInner} ${rInner} 0 ${largeArc} 0 ${p4.x} ${p4.y}`,
      'Z'
    ].join(' ');
  }

  // Keep text mostly upright: flip 180Â° if on bottom half.
  function uprightTextRotation(angleDeg) {
    const a = ((angleDeg % 360) + 360) % 360;
    return (a > 90 && a < 270) ? 180 : 0;
  }

  /**
   * ==========================================================
   * Wheel building
   * ==========================================================
   */
  const RAD = {
    slotIn: 240, slotOut: 280,
    aIn: 195, aOut: 235,
    bIn: 150, bOut: 190,
    cIn: 105, cOut: 145,
  };

  function clearGroup(g) { while (g.firstChild) g.removeChild(g.firstChild); }

  function buildSlotRing() {
    clearGroup(el.slotRing);

    for (let slot = 1; slot <= SLOTS; slot++) {
      const start = (slot - 1) * STEP_DEG;
      const end = slot * STEP_DEG;
      const mid = start + STEP_DEG / 2;

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.classList.add('slotWedge');
      g.dataset.slot = String(slot);

      const isReserved = RESERVED.has(slot);
      if (isReserved) g.classList.add('house');

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', wedgePath(RAD.slotIn, RAD.slotOut, start, end));
      path.setAttribute('stroke-width', '1.2');

      if (isReserved) {
        path.setAttribute('fill', 'var(--reservedFill)');
        path.setAttribute('stroke', 'var(--reservedStroke)');
      } else {
        path.setAttribute('fill', 'rgba(0,0,0,0.16)');
        path.setAttribute('stroke', 'rgba(120,255,160,0.16)');
      }

      const pos = polar(CX, CY, (RAD.slotIn + RAD.slotOut) / 2, mid);

      const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      txt.classList.add('slotText');
      if (isReserved) txt.classList.add('house');
      txt.setAttribute('x', pos.x);
      txt.setAttribute('y', pos.y);
      txt.setAttribute('text-anchor', 'middle');
      txt.setAttribute('dominant-baseline', 'middle');
      txt.textContent = String(slot);

      const flip = uprightTextRotation(mid);
      txt.setAttribute('transform', `rotate(${mid + flip} ${pos.x} ${pos.y})`);

      if (!isReserved) {
        g.addEventListener('click', () => toggleSlot(slot));
      }

      g.appendChild(path);
      g.appendChild(txt);
      el.slotRing.appendChild(g);
    }
  }

  function buildSymbolRing(groupEl, ringSymbols, rInner, rOuter) {
    clearGroup(groupEl);

    for (let i = 0; i < SLOTS; i++) {
      const slot = i + 1;
      const start = i * STEP_DEG;
      const end = (i + 1) * STEP_DEG;
      const mid = start + STEP_DEG / 2;

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.dataset.slot = String(slot);

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', wedgePath(rInner, rOuter, start, end));
      path.setAttribute('fill', 'rgba(0,0,0,0.18)');
      path.setAttribute('stroke', 'rgba(120,255,160,0.12)');
      path.setAttribute('stroke-width', '1.0');

      const sym = ringSymbols[i];
      const glyph = GLYPH[sym] ?? sym[0];

      const pos = polar(CX, CY, (rInner + rOuter) / 2, mid);

      const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      txt.classList.add('symbolGlyph');
      txt.setAttribute('x', pos.x);
      txt.setAttribute('y', pos.y);
      txt.setAttribute('text-anchor', 'middle');
      txt.setAttribute('dominant-baseline', 'middle');
      txt.textContent = glyph;

      const flip = uprightTextRotation(mid);
      txt.setAttribute('transform', `rotate(${mid + flip} ${pos.x} ${pos.y})`);

      g.appendChild(path);
      g.appendChild(txt);
      groupEl.appendChild(g);
    }
  }

  /**
   * ==========================================================
   * Selection state (click/tap only)
   * ==========================================================
   */
  function syncSelectionUI() {
    el.slotRing.querySelectorAll('g.slotWedge').forEach(w => {
      const slot = Number(w.dataset.slot);
      w.classList.toggle('selected', state.selected.includes(slot));
    });
    renderChips();
  }

  function renderChips() {
    el.chips.innerHTML = '';
    if (state.selected.length === 0) {
      el.slotsHint.textContent = 'No slots selected.';
      return;
    }

    el.slotsHint.textContent = `Selected: ${state.selected.join(', ')}`;

    for (const slot of state.selected) {
      const chip = document.createElement('div');
      chip.className = 'chip';
      chip.innerHTML = `SLOT ${slot} <button title="Remove slot ${slot}">Ã—</button>`;
      chip.querySelector('button').addEventListener('click', () => {
        state.selected = state.selected.filter(s => s !== slot);
        syncSelectionUI();
      });
      el.chips.appendChild(chip);
    }
  }

  function toggleSlot(slot) {
    if (state.spinning) return;
    if (RESERVED.has(slot)) return;

    if (state.selected.includes(slot)) {
      state.selected = state.selected.filter(s => s !== slot);
    } else {
      if (state.selected.length >= 3) return;
      state.selected = [...state.selected, slot].sort((a,b)=>a-b);
    }
    syncSelectionUI();
  }

  function clearSelection() {
    state.selected = [];
    syncSelectionUI();
  }

  /**
   * ==========================================================
   * Rotation + animation
   * ==========================================================
   * We rotate symbol rings with: rotate(deg cx cy)
   * SVG positive degrees rotate clockwise; we spin CCW by using negative velocities.
   */
  function setGroupRotation(groupEl, deg) {
    groupEl.setAttribute('transform', `rotate(${deg} ${CX} ${CY})`);
  }

  function mod(n, m) { return ((n % m) + m) % m; }

  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  function computeTargetDeg(currentDeg, targetPhaseDeg, extraRevs) {
    const curPhase = mod(currentDeg, 360);
    const tgtPhase = mod(targetPhaseDeg, 360);

    // Delta in (-360, 0] for CCW-only travel:
    let phaseDelta = tgtPhase - curPhase;
    phaseDelta = mod(phaseDelta, 360);
    if (phaseDelta > 0) phaseDelta -= 360;

    return currentDeg + phaseDelta - (extraRevs * 360);
  }

  function makeAnim(getDeg, setDeg) {
    return {
      phase: 'idle',
      getDeg, setDeg,
      vel: 0, // deg/sec (negative for CCW)
      decelStartDeg: 0,
      decelEndDeg: 0,
      decelStartMs: 0,
      decelDurMs: 0,
    };
  }

  const animA = makeAnim(() => state.rotA, (d) => { state.rotA = d; setGroupRotation(el.ringA, d); });
  const animB = makeAnim(() => state.rotB, (d) => { state.rotB = d; setGroupRotation(el.ringB, d); });
  const animC = makeAnim(() => state.rotC, (d) => { state.rotC = d; setGroupRotation(el.ringC, d); });

  function startDecel(anim, nowMs, endDeg, durMs) {
    anim.phase = 'decel';
    anim.decelStartDeg = anim.getDeg();
    anim.decelEndDeg = endDeg;
    anim.decelStartMs = nowMs;
    anim.decelDurMs = durMs;
    anim.vel = 0;
  }

  let rafId = 0;

  function runUntilStop() {
    return new Promise(resolve => {
      const last = { t: performance.now() };

      function tick(now) {
        const dt = (now - last.t) / 1000;
        last.t = now;

        const rings = [animA, animB, animC];

        for (const a of rings) {
          if (a.phase === 'cruise') {
            a.setDeg(a.getDeg() + a.vel * dt);
          } else if (a.phase === 'decel') {
            const t = Math.min(1, (now - a.decelStartMs) / a.decelDurMs);
            const e = easeOutCubic(t);
            a.setDeg(a.decelStartDeg + (a.decelEndDeg - a.decelStartDeg) * e);
            if (t >= 1) a.phase = 'stopped';
          }
        }

        const anyMoving = rings.some(a => a.phase === 'cruise' || a.phase === 'decel');
        if (anyMoving) rafId = requestAnimationFrame(tick);
        else resolve();
      }

      rafId = requestAnimationFrame(tick);
    });
  }

  /**
   * ==========================================================
   * Results table rendering
   * ==========================================================
   */
  function renderResults(rows) {
    el.resultsBody.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.slot}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sa] ?? r.sa}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sb] ?? r.sb}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${GLYPH[r.sc] ?? r.sc}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.match}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.mult}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(120,255,160,0.10);">${r.win}</td>
      `;
      el.resultsBody.appendChild(tr);
    }
    el.resultsTable.style.display = '';
  }

  /**
   * ==========================================================
   * Quark modal dialog
   * ==========================================================
   * Requirements:
   *  - OK button to continue
   *  - Quark jape/remark
   *  - Large, clear ASCII Quark
   *  - Aesthetic matches terminal
   *  - Esc/backdrop closes; focus restored to Spin
   */

  // Big ASCII â€œQuark-ishâ€ Ferengi bartender vibe (original, not show quotes/art).
  const QUARK_ASCII = String.raw`
                       ______________________________
                      /                              \
             ________/   QUARK'S FRIENDLY ADVICE      \________
            /   ____  \                                /  ____  \
           /   /    \  \____                    ____  /  /    \  \
          |   |  ()  |      \__________________/      |  |  ()  |  |
          |   |      |   .----.   .----.   .----.     |  |      |  |
          |   |  __  |  / ____ \ / ____ \ / ____ \    |  |  __  |  |
          |   | /  \ | | |    | | |    | | |    | |   | | /  \ |  |
          |   | \__/ | | |____| | |____| | |____| |   | | \__/ |  |
          |   |      |  \______/ \______/ \______/    |  |      |  |
          |   |______|     .--------------------.      |  |______|  |
          |      __        |  LATINUM COUNTS.    |      |      __    |
          |     /  \       |  HONOR IS OPTIONAL. |      |     /  \   |
          |    / /\ \      '--------------------'      |    / /\ \  |
          |   /_/  \_\      ___      ___      ___      |   /_/  \_\ |
          |    /      \    /___\    /___\    /___\     |    /      \|
          |   /  /\    \     |        |        |       |   /  /\    \
          |  /__/  \____\    |        |        |       |  /__/  \____\
          |      (  )        |        |        |       |      (  )
          |       \/        _|_      _|_      _|_      |       \/
          |__________________________________________________________|
`;

  const QUARK_REMARKS = {
    jackpot: [
      "Thatâ€™s not luck â€” thatâ€™s destiny with a tab.",
      "Jackpot! Iâ€™ll justâ€¦ hold onto your winnings for â€œsafekeeping.â€",
      "You hit the big one. Try not to faint on my floor.",
    ],
    win: [
      "A profit! Iâ€™m thrilled. Deeply. Spiritually. Now spin again.",
      "See? The wheel likes you. Iâ€™m not jealous. Not at all.",
      "Winnings! Donâ€™t spend it all on ethics and self-respect.",
    ],
    loss: [
      "A learning experience! For you. Financially.",
      "The wheel is innocent. Your strategy, howeverâ€¦",
      "No hit. But think of the character youâ€™re building. Very expensive character.",
    ]
  };

  function pick(arr) {
    return arr[randInt(0, arr.length)];
  }

  function openModal({ title, sub, summaryHTML, remark }) {
    state.lastFocusEl = document.activeElement;

    el.modalTitle.textContent = title;
    el.modalSub.textContent = sub;
    el.modalSummary.innerHTML = summaryHTML;
    el.modalRemark.textContent = remark;
    el.quarkAscii.textContent = QUARK_ASCII;

    el.modal.classList.remove('hidden');

    // Move focus to OK (best-practice for dialogs)
    setTimeout(() => el.modalOk.focus(), 0);
  }

  function closeModal() {
    el.modal.classList.add('hidden');

    // Restore focus to a sensible place (Spin button preferred)
    const restore = state.lastFocusEl;
    state.lastFocusEl = null;

    if (restore && typeof restore.focus === 'function') restore.focus();
    else el.spinBtn.focus();
  }

  function showResultModal({ stake, won, net, bankroll }) {
    let title, sub, remarkKey;

    if (won > 0 && net > 0) {
      title = (won >= stake * 1000) ? "JACKPOT RESULT" : "WIN RESULT";
      sub = "The wheel has spoken. Quark has opinions.";
      remarkKey = (won >= stake * 1000) ? "jackpot" : "win";
    } else if (won === 0) {
      title = "LOSS RESULT";
      sub = "The wheel has spoken. Quark hasâ€¦ relief.";
      remarkKey = "loss";
    } else {
      title = "RESULT";
      sub = "Quark is calculating your value as a customer.";
      remarkKey = "loss";
    }

    const summaryHTML = `
      <div><b>Stake:</b> ${stake}</div>
      <div><b>Winnings:</b> ${won}</div>
      <div><b>Net:</b> ${net}</div>
      <div><b>Bankroll:</b> ${bankroll}</div>
    `;

    openModal({
      title,
      sub,
      summaryHTML,
      remark: pick(QUARK_REMARKS[remarkKey]),
    });
  }

  // Modal closing behaviors
  el.modalOk.addEventListener('click', closeModal);
  el.modalBackdrop.addEventListener('click', closeModal);
  window.addEventListener('keydown', (e) => {
    if (el.modal.classList.contains('hidden')) return;
    if (e.key === 'Escape') closeModal();
  });

  /**
   * ==========================================================
   * Spin orchestration
   * ==========================================================
   */
  async function spin() {
    if (state.spinning) return;

    if (state.selected.length < 1 || state.selected.length > 3) {
      setStatus('ERROR // SELECT 1â€“3 BETTABLE SLOTS', 'bad');
      return;
    }

    const vb = validateBet(state.selected.length);
    if (!vb.ok) {
      setStatus(`ERROR // ${vb.reason}`, 'bad');
      return;
    }
    const bet = vb.bet;

    // Stake immediately.
    const stake = bet * state.selected.length;
    state.bankroll -= stake;
    updateBankroll();

    setSpinning(true);
    setStatus('SPINNING // WATCH THE WHEEL', 'warn');
    el.spinMeta.textContent = '';
    el.resultsTable.style.display = 'none';

    // Choose final offsets per ring (0..35).
    const final = {
      a: randInt(0, SLOTS),
      b: randInt(0, SLOTS),
      c: randInt(0, SLOTS),
    };

    // Desired final phase degrees: angle = -offset * 10Â° (CCW)
    const targetPhaseA = -final.a * STEP_DEG;
    const targetPhaseB = -final.b * STEP_DEG;
    const targetPhaseC = -final.c * STEP_DEG;

    if (prefersReducedMotion()) {
      state.rotA = targetPhaseA; state.rotB = targetPhaseB; state.rotC = targetPhaseC;
      setGroupRotation(el.ringA, state.rotA);
      setGroupRotation(el.ringB, state.rotB);
      setGroupRotation(el.ringC, state.rotC);
      animA.phase = animB.phase = animC.phase = 'stopped';
    } else {
      // Cruise speeds (deg/sec), negative for CCW.
      animA.phase = 'cruise'; animA.vel = -randInt(220, 300);
      animB.phase = 'cruise'; animB.vel = -randInt(260, 340);
      animC.phase = 'cruise'; animC.vel = -randInt(300, 420);

      // Deterministic end degrees with extra revolutions.
      const endA = computeTargetDeg(state.rotA, targetPhaseA, randInt(5, 9));
      const endB = computeTargetDeg(state.rotB, targetPhaseB, randInt(6, 10));
      const endC = computeTargetDeg(state.rotC, targetPhaseC, randInt(7, 11));

      const loop = runUntilStop();

      // Sequential stops: A then B then C
      setTimeout(() => startDecel(animA, performance.now(), endA, randInt(900, 1400)), randInt(700, 1000));
      setTimeout(() => startDecel(animB, performance.now(), endB, randInt(950, 1500)), randInt(950, 1250));
      setTimeout(() => startDecel(animC, performance.now(), endC, randInt(1000, 1600)), randInt(1200, 1500));

      await loop;

      // Snap exactly to phase to avoid drift.
      state.rotA = targetPhaseA;
      state.rotB = targetPhaseB;
      state.rotC = targetPhaseC;
      setGroupRotation(el.ringA, state.rotA);
      setGroupRotation(el.ringB, state.rotB);
      setGroupRotation(el.ringC, state.rotC);
    }

    // Evaluate results
    const rows = [];
    let totalWin = 0;

    for (const slot of state.selected) {
      const [sa, sb, sc] = symbolsAtSlot(slot, final);
      const mult = payoutMultiplier([sa, sb, sc]);
      const win = bet * mult;
      totalWin += win;
      rows.push({ slot, sa, sb, sc, mult, win, match: matchLabel(mult) });
    }

    state.bankroll += totalWin;
    updateBankroll();

    const net = totalWin - stake;

    el.spinMeta.textContent =
      `Offsets: A=${final.a}, B=${final.b}, C=${final.c} â€” Staked ${stake}, Won ${totalWin}, Net ${net}`;
    renderResults(rows);

    if (totalWin > 0) setStatus('DABO! // PROFIT ACHIEVED', 'ok');
    else setStatus('NO HIT // REASSESS YOUR STRATEGY', 'muted');

    if (state.bankroll < MIN_BET) {
      setStatus('INSUFFICIENT FUNDS // RESET REQUIRED', 'bad');
      el.spinBtn.disabled = true;
    }

    setSpinning(false);

    // Show the Quark result dialog after the spin resolves
    showResultModal({
      stake,
      won: totalWin,
      net,
      bankroll: state.bankroll
    });
  }

  function resetAll() {
    cancelAnimationFrame(rafId);

    state.bankroll = 1000;
    updateBankroll();

    state.rotA = 0; state.rotB = 0; state.rotC = 0;
    setGroupRotation(el.ringA, 0);
    setGroupRotation(el.ringB, 0);
    setGroupRotation(el.ringC, 0);

    animA.phase = animB.phase = animC.phase = 'idle';

    clearSelection();

    el.betInput.value = '';
    el.betHint.textContent = '';
    el.spinMeta.textContent = '';
    el.resultsTable.style.display = 'none';

    el.spinBtn.disabled = false;
    setStatus('SELECT SLOTS, ENTER BET, THEN SPIN.', 'muted');
  }

  /**
   * ==========================================================
   * Init
   * ==========================================================
   */
  function init() {
    buildSlotRing();
    buildSymbolRing(el.ringA, RING_A, RAD.aIn, RAD.aOut);
    buildSymbolRing(el.ringB, RING_B, RAD.bIn, RAD.bOut);
    buildSymbolRing(el.ringC, RING_C, RAD.cIn, RAD.cOut);

    setGroupRotation(el.ringA, state.rotA);
    setGroupRotation(el.ringB, state.rotB);
    setGroupRotation(el.ringC, state.rotC);

    updateBankroll();
    clearSelection();
    setStatus('SELECT SLOTS, ENTER BET, THEN SPIN.', 'muted');

    el.spinBtn.addEventListener('click', spin);
    el.clearBtn.addEventListener('click', () => { clearSelection(); setStatus('SELECTION CLEARED.', 'muted'); });
    el.resetBtn.addEventListener('click', resetAll);

    el.betInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') spin();
    });
    el.betInput.addEventListener('input', () => {
      if (state.selected.length > 0) validateBet(state.selected.length);
    });

    // If modal is open and user rotates device, layout is already responsive via CSS.
    // Still, we can re-sync selection highlight safely.
    window.addEventListener('resize', () => syncSelectionUI(), { passive:true });
  }

  init();
})();
</script>
</body>
</html>