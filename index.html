<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dabo (Browser)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; line-height: 1.35; }
    .wrap { max-width: 980px; margin: 0 auto; }
    h1 { margin: 0 0 8px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: end; }
    label { display: block; font-size: 14px; margin-bottom: 6px; }
    input, button { font: inherit; padding: 10px 12px; }
    input { width: 260px; }
    button { cursor: pointer; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin-top: 16px; }
    .muted { color: #555; font-size: 14px; }
    .ok { color: #0a7; font-weight: 600; }
    .bad { color: #b00; font-weight: 600; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { border-bottom: 1px solid #eee; padding: 10px 8px; text-align: left; }
    th { font-size: 13px; text-transform: uppercase; letter-spacing: 0.04em; color: #555; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
    .pill { display: inline-block; padding: 3px 10px; border-radius: 999px; background: #f6f6f6; font-size: 12px; }
    .hint { font-size: 13px; color: #666; margin-top: 6px; }
    .footer { margin-top: 20px; font-size: 12px; color: #666; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Dabo</h1>
  <div class="muted">Three rings stop; you win when symbols align on your chosen slots.</div>

  <div class="card">
    <div class="row">
      <div class="grid" style="min-width: 300px;">
        <div><span class="pill" id="bankrollPill">Bankroll: 1000</span></div>
        <div class="muted">Unbettable (house-only): <code>5â€“7</code>, <code>17â€“19</code>, <code>29â€“31</code></div>
      </div>

      <div>
        <label for="slotsInput">Slots (1â€“36), pick 1â€“3 (space or comma separated)</label>
        <input id="slotsInput" placeholder="e.g. 3 12 21" />
        <div class="hint" id="slotsHint"></div>
      </div>

      <div>
        <label for="betInput">Bet per slot (10â€“100)</label>
        <input id="betInput" placeholder="10" />
        <div class="hint" id="betHint"></div>
      </div>

      <div>
        <button id="spinBtn">Spin</button>
      </div>
    </div>

    <div id="status" style="margin-top: 12px;"></div>
    <div id="spinMeta" class="muted" style="margin-top: 10px;"></div>

    <table id="resultsTable" aria-label="results" style="display:none;">
      <thead>
        <tr>
          <th>Slot</th>
          <th>Ring A</th>
          <th>Ring B</th>
          <th>Ring C</th>
          <th>Match</th>
          <th>Mult</th>
          <th>Win</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <div class="footer">
      Payouts: <code>QUARK+SWIRL+SWIRL</code> = 4000Ã—, 3-kind = 100Ã—, 2-kind = 5Ã—.
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

  // ----------------------------- Config -----------------------------
  const SLOTS = 36;
  const MIN_BET = 10;
  const MAX_BET = 100;

  const UNBETTABLE = new Set([5,6,7,17,18,19,29,30,31]);

  const SYMBOLS = {
    BAR: 'BAR',
    ORB: 'ORB',
    COMET: 'COMET',
    BOLT: 'BOLT',
    MOON: 'MOON',
    SUN: 'SUN',
    SWIRL: 'SWIRL',
    DS9: 'DS9',
    QUARK: 'QUARK',
  };

  const COMMON_PATTERN = [
    SYMBOLS.BAR, SYMBOLS.ORB, SYMBOLS.COMET, SYMBOLS.BOLT,
    SYMBOLS.MOON, SYMBOLS.SUN, SYMBOLS.BOLT, SYMBOLS.ORB,
  ];

  function buildRing(seedShift = 0) {
    const ring = Array.from({ length: SLOTS }, (_, i) => COMMON_PATTERN[(i + seedShift) % COMMON_PATTERN.length]);

    // Special icons (1-based)
    ring[17 - 1] = SYMBOLS.QUARK;
    ring[8 - 1]  = SYMBOLS.SWIRL;
    ring[28 - 1] = SYMBOLS.SWIRL;
    ring[11 - 1] = SYMBOLS.DS9;
    ring[22 - 1] = SYMBOLS.DS9;
    ring[34 - 1] = SYMBOLS.DS9;

    return ring;
  }

  const RING_A = buildRing(0);
  const RING_B = buildRing(3);
  const RING_C = buildRing(5);

  // -------------------------- Game Mechanics ------------------------
  // Browser-safe randomness
  function randInt(minInclusive, maxExclusive) {
    // crypto.getRandomValues gives stronger randomness than Math.random()
    const range = maxExclusive - minInclusive;
    const maxUint = 0xFFFFFFFF;
    const limit = maxUint - (maxUint % range);

    const buf = new Uint32Array(1);
    let x;
    do {
      crypto.getRandomValues(buf);
      x = buf[0];
    } while (x >= limit);

    return minInclusive + (x % range);
  }

  function spinOffsets() {
    return {
      a: randInt(0, SLOTS),
      b: randInt(0, SLOTS),
      c: randInt(0, SLOTS),
    };
  }

  function symbolsAtSlot(slot1Based, offsets) {
    const i = (slot1Based - 1) % SLOTS;
    const sa = RING_A[(i + offsets.a) % SLOTS];
    const sb = RING_B[(i + offsets.b) % SLOTS];
    const sc = RING_C[(i + offsets.c) % SLOTS];
    return [sa, sb, sc];
  }

  function payoutMultiplier([sa, sb, sc]) {
    const trio = [sa, sb, sc].slice().sort();
    const sorted = trio.join('|');

    if (sorted === [SYMBOLS.QUARK, SYMBOLS.SWIRL, SYMBOLS.SWIRL].sort().join('|')) return 4000;
    if (sa === sb && sb === sc) return 100;
    if (sa === sb || sa === sc || sb === sc) return 5;
    return 0;
  }

  function isBettable(slot1Based) {
    return slot1Based >= 1 && slot1Based <= SLOTS && !UNBETTABLE.has(slot1Based);
  }

  function parseSlots(raw) {
    const parts = raw.split(/[\s,]+/).filter(Boolean);
    const nums = parts.map(p => Number(p)).filter(n => Number.isFinite(n) && Number.isInteger(n));
    const unique = [...new Set(nums)];
    return unique.sort((a,b) => a-b);
  }

  // ------------------------------ UI --------------------------------
  let bankroll = 1000;

  const el = {
    bankrollPill: document.getElementById('bankrollPill'),
    slotsInput: document.getElementById('slotsInput'),
    betInput: document.getElementById('betInput'),
    spinBtn: document.getElementById('spinBtn'),
    status: document.getElementById('status'),
    spinMeta: document.getElementById('spinMeta'),
    resultsTable: document.getElementById('resultsTable'),
    tbody: document.querySelector('#resultsTable tbody'),
    slotsHint: document.getElementById('slotsHint'),
    betHint: document.getElementById('betHint'),
  };

  function setStatus(msg, kind = 'muted') {
    el.status.className = kind;
    el.status.textContent = msg;
  }

  function updateBankroll() {
    el.bankrollPill.textContent = `Bankroll: ${bankroll}`;
    const maxAffordable = Math.floor(bankroll / 1);
    el.betHint.textContent = `Your bankroll supports up to ${maxAffordable} total stake.`;
  }

  function validateInputs() {
    const slots = parseSlots(el.slotsInput.value.trim());
    if (slots.length < 1 || slots.length > 3) {
      el.slotsHint.textContent = 'Pick 1â€“3 unique slots.';
      return { ok: false, reason: 'Pick 1â€“3 unique slots.' };
    }
    if (!slots.every(isBettable)) {
      el.slotsHint.textContent = 'One or more slots are invalid/unbettable.';
      return { ok: false, reason: 'One or more slots are invalid/unbettable.' };
    }
    el.slotsHint.textContent = `Selected: ${slots.join(', ')}`;

    const betRaw = el.betInput.value.trim();
    const bet = betRaw === '' ? MIN_BET : Number(betRaw);
    if (!Number.isFinite(bet) || !Number.isInteger(bet)) {
      el.betHint.textContent = 'Bet must be a whole number.';
      return { ok: false, reason: 'Bet must be a whole number.' };
    }

    const maxAffordablePerSlot = Math.floor(bankroll / slots.length);
    const effectiveMax = Math.min(MAX_BET, maxAffordablePerSlot);

    if (bet < MIN_BET || bet > effectiveMax) {
      el.betHint.textContent = `Bet per slot must be ${MIN_BET}â€“${effectiveMax} (based on bankroll).`;
      return { ok: false, reason: 'Bet out of range.' };
    }

    el.betHint.textContent = `Total stake: ${bet * slots.length}.`;
    return { ok: true, slots, bet };
  }

  function renderResults(rows) {
    el.tbody.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.slot}</td>
        <td>${r.sa}</td>
        <td>${r.sb}</td>
        <td>${r.sc}</td>
        <td>${r.match}</td>
        <td>${r.mult}</td>
        <td>${r.win}</td>
      `;
      el.tbody.appendChild(tr);
    }
    el.resultsTable.style.display = '';
  }

  function matchLabel(mult) {
    if (mult === 4000) return 'JACK';
    if (mult === 100) return '3K';
    if (mult === 5) return '2K';
    return '--';
  }

  function spin() {
    const v = validateInputs();
    if (!v.ok) {
      setStatus(v.reason, 'bad');
      return;
    }

    const { slots, bet } = v;
    const stake = bet * slots.length;
    bankroll -= stake;

    const offsets = spinOffsets();
    const rows = [];
    let totalWin = 0;

    for (const slot of slots) {
      const [sa, sb, sc] = symbolsAtSlot(slot, offsets);
      const mult = payoutMultiplier([sa, sb, sc]);
      const win = bet * mult;
      totalWin += win;

      rows.push({
        slot,
        sa, sb, sc,
        mult,
        win,
        match: matchLabel(mult),
      });
    }

    bankroll += totalWin;

    el.spinMeta.textContent = `Offsets: A=${offsets.a}, B=${offsets.b}, C=${offsets.c} â€” Staked ${stake}, Won ${totalWin}, Net ${totalWin - stake}`;
    renderResults(rows);

    if (totalWin > 0) setStatus('DABO! ðŸ’°', 'ok');
    else setStatus('No hits â€” spin again.', 'muted');

    if (bankroll < MIN_BET) {
      setStatus('Youâ€™re out of spending money. Refresh to restart.', 'bad');
      el.spinBtn.disabled = true;
    }

    updateBankroll();
  }

  el.spinBtn.addEventListener('click', spin);
  el.slotsInput.addEventListener('input', () => { validateInputs(); });
  el.betInput.addEventListener('input', () => { validateInputs(); });

  // init
  updateBankroll();
  setStatus('Enter slots + bet, then Spin.', 'muted');
})();
</script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dabo // Ferengi Terminal</title>
  <style>
    :root{
      --bg0:#060707;
      --bg1:#0a0c0b;
      --panel:#0b120f;
      --panel2:#0b1511;
      --ink:#b7ffbf;           /* phosphor */
      --ink2:#7bff8f;
      --warn:#ffd07a;
      --bad:#ff7a7a;

      --brass0:#3a240a;
      --brass1:#7a4f12;
      --brass2:#d2a84b;
      --brass3:#f7d57e;

      --grid: rgba(90, 180, 120, 0.08);
      --glow: 0 0 10px rgba(120,255,160,0.25), 0 0 30px rgba(120,255,160,0.09);
      --cell: clamp(28px, 3.2vw, 48px);
      --gap: 6px;
      --radius: 16px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: var(--ink);
      background:
        radial-gradient(1000px 700px at 20% 0%, rgba(90,180,120,0.10), transparent 55%),
        radial-gradient(800px 600px at 70% 20%, rgba(210,168,75,0.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    .wrap{ max-width: 1100px; margin: 22px auto; padding: 0 16px 32px; }

    /* Ferengi frame */
    .frame{
      position:relative;
      border-radius: 26px;
      padding: 14px;
      background:
        linear-gradient(135deg, rgba(210,168,75,0.25), rgba(210,168,75,0.06) 35%, rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(30, 18, 4, 0.65), rgba(10, 8, 5, 0.75));
      box-shadow:
        0 18px 70px rgba(0,0,0,0.6),
        inset 0 0 0 1px rgba(247,213,126,0.18);
    }
    .frame:before{
      content:"";
      position:absolute; inset:10px;
      border-radius: 22px;
      background:
        linear-gradient(180deg, rgba(210,168,75,0.18), rgba(210,168,75,0.02) 40%, rgba(0,0,0,0) 100%);
      pointer-events:none;
      mix-blend-mode: screen;
    }

    .terminal{
      position:relative;
      border-radius: 18px;
      padding: 18px;
      background:
        linear-gradient(180deg, rgba(10,24,18,0.92), rgba(6,12,9,0.92));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.12),
        inset 0 0 40px rgba(0,0,0,0.6);
      overflow:hidden;
    }

    /* scanlines + subtle CRT shimmer */
    .terminal:before{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.05) 0px,
          rgba(255,255,255,0.03) 1px,
          rgba(0,0,0,0.00) 2px,
          rgba(0,0,0,0.00) 5px
        );
      opacity:0.10;
      pointer-events:none;
    }
    .terminal:after{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(closest-side at 30% 40%, rgba(120,255,160,0.08), transparent 60%),
        radial-gradient(closest-side at 70% 30%, rgba(210,168,75,0.08), transparent 65%);
      animation: shimmer 7s ease-in-out infinite alternate;
      pointer-events:none;
      opacity:0.9;
    }
    @keyframes shimmer{
      from{ transform: translate3d(-8px,-4px,0); filter: blur(0px); }
      to{ transform: translate3d(10px,8px,0); filter: blur(0.6px); }
    }

    .topbar{
      display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      margin-bottom: 14px;
    }
    .title{
      display:flex; gap:10px; align-items:baseline; flex-wrap:wrap;
      text-shadow: var(--glow);
    }
    .title h1{
      margin:0; font-size: 22px; letter-spacing: 0.08em; font-weight: 800;
    }
    .subtitle{
      font-size: 12px; color: rgba(183,255,191,0.75);
      letter-spacing: 0.09em;
    }

    .statusrow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end;
    }

    .pill{
      display:inline-flex; gap:10px; align-items:center;
      padding: 8px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(120,255,160,0.10), rgba(120,255,160,0.04));
      box-shadow: inset 0 0 0 1px rgba(120,255,160,0.16);
      font-size: 12px;
      letter-spacing:0.06em;
    }
    .pill strong{ color: var(--ink2); }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr 0.7fr;
      gap: 14px;
      margin-top: 14px;
    }
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: var(--radius);
      padding: 14px;
      background:
        linear-gradient(180deg, rgba(10,22,16,0.80), rgba(8,14,11,0.82));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.10),
        0 10px 30px rgba(0,0,0,0.35);
      position:relative;
      overflow:hidden;
    }
    .panel:before{
      content:"";
      position:absolute; inset:0;
      background:
        linear-gradient(90deg, transparent, rgba(90,180,120,0.12), transparent);
      opacity:0.25;
      transform: translateX(-60%);
      animation: sweep 9s linear infinite;
      pointer-events:none;
    }
    @keyframes sweep{
      0%{ transform: translateX(-60%); }
      100%{ transform: translateX(120%); }
    }

    .panel h2{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(183,255,191,0.82);
    }
    .muted{ color: rgba(183,255,191,0.68); font-size: 12px; line-height: 1.4; }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }
    .ok{ color: var(--ink2); }

    label{ display:block; margin: 10px 0 6px; font-size: 12px; letter-spacing:0.08em; color: rgba(183,255,191,0.85); }
    input, button{
      font: inherit;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(120,255,160,0.18);
      background: rgba(0,0,0,0.25);
      color: var(--ink);
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    input::placeholder{ color: rgba(183,255,191,0.35); }
    input:focus{
      border-color: rgba(120,255,160,0.40);
      box-shadow: 0 0 0 3px rgba(120,255,160,0.08), inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    button{
      cursor:pointer;
      border-color: rgba(210,168,75,0.35);
      background:
        linear-gradient(180deg, rgba(210,168,75,0.22), rgba(210,168,75,0.08));
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 8px 18px rgba(0,0,0,0.35);
      letter-spacing:0.08em;
      text-transform: uppercase;
      font-weight: 800;
    }
    button:hover{ filter: brightness(1.06); }
    button:disabled{
      cursor:not-allowed;
      opacity: 0.6;
      filter: saturate(0.7);
    }

    /* Wheel */
    .wheelWrap{
      border-radius: 18px;
      background:
        linear-gradient(180deg, rgba(210,168,75,0.12), rgba(0,0,0,0) 35%),
        linear-gradient(180deg, rgba(8,18,13,0.70), rgba(5,10,7,0.72));
      box-shadow:
        inset 0 0 0 1px rgba(247,213,126,0.20),
        inset 0 0 30px rgba(0,0,0,0.6),
        0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      position:relative;
    }
    .wheelWrap:before{
      content:"";
      position:absolute; inset:0;
      background:
        linear-gradient(90deg, rgba(210,168,75,0.16), transparent 18%, transparent 82%, rgba(210,168,75,0.16));
      pointer-events:none;
      opacity:0.65;
    }
    .wheelHeader{
      padding: 12px 12px 8px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      border-bottom: 1px solid rgba(120,255,160,0.12);
      position:relative;
    }
    .wheelHeader .muted{ font-size: 11px; letter-spacing:0.08em; }
    .legend{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;
    }
    .legend span{
      font-size: 11px;
      color: rgba(183,255,191,0.75);
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(120,255,160,0.12);
      padding: 4px 8px;
      border-radius: 999px;
    }

    .slotRuler{
      display:grid;
      grid-template-columns: repeat(36, minmax(0, 1fr));
      gap: 0;
      padding: 8px 10px 0;
      font-size: 10px;
      color: rgba(183,255,191,0.55);
      user-select:none;
    }
    .slotRuler div{
      text-align:center;
      padding: 2px 0 8px;
      border-bottom: 1px dashed rgba(120,255,160,0.10);
      position:relative;
    }
    .slotRuler .house{
      color: rgba(255,208,122,0.55);
    }
    .slotRuler .selected::after{
      content:"";
      position:absolute; left:50%; bottom:-2px;
      width: 0; height:0;
      border-left: 6px solid transparent;
      border-right:6px solid transparent;
      border-top: 7px solid rgba(210,168,75,0.85);
      transform: translateX(-50%);
      filter: drop-shadow(0 0 6px rgba(210,168,75,0.3));
    }

    .window{
      position:relative;
      overflow:hidden;
      padding: 10px;
    }

    .ringRow{
      display:flex; align-items:center; gap: 10px;
      margin: 10px 0;
    }
    .ringLabel{
      width: 86px;
      font-size: 12px;
      letter-spacing:0.12em;
      text-transform: uppercase;
      color: rgba(183,255,191,0.75);
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .ringLabel b{ color: rgba(247,213,126,0.85); font-weight: 900; }

    .viewport{
      flex: 1;
      overflow:hidden;
      border-radius: 14px;
      background:
        linear-gradient(180deg, rgba(0,0,0,0.32), rgba(0,0,0,0.18));
      box-shadow:
        inset 0 0 0 1px rgba(120,255,160,0.10),
        inset 0 0 18px rgba(0,0,0,0.55);
      position:relative;
    }
    .viewport:before{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(90deg, var(--grid) 0px, var(--grid) 1px, transparent 1px, transparent 24px);
      opacity:0.25;
      pointer-events:none;
    }

    .track{
      display:flex;
      width: max-content;
      will-change: transform;
      transform: translate3d(0,0,0);
      padding: 10px 10px;
      gap: var(--gap);
    }

    .cell{
      width: var(--cell);
      height: calc(var(--cell) * 0.92);
      border-radius: 12px;
      border: 1px solid rgba(120,255,160,0.12);
      background:
        linear-gradient(180deg, rgba(120,255,160,0.08), rgba(0,0,0,0.18));
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 3px 12px rgba(0,0,0,0.35);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap: 2px;
      user-select:none;
      position:relative;
    }

    .cell .g{
      font-size: 16px;
      filter: drop-shadow(0 0 10px rgba(120,255,160,0.15));
    }
    .cell .t{
      font-size: 10px;
      color: rgba(183,255,191,0.75);
      letter-spacing:0.06em;
    }

    .cell.selected{
      border-color: rgba(210,168,75,0.50);
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,0.35),
        0 0 0 2px rgba(210,168,75,0.22),
        0 8px 22px rgba(210,168,75,0.14);
    }

    .cell.house::after{
      content:"HOUSE";
      position:absolute;
      top: -7px; right: -7px;
      font-size: 9px;
      letter-spacing:0.08em;
      padding: 2px 6px;
      border-radius: 999px;
      color: rgba(255,208,122,0.85);
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,208,122,0.22);
      box-shadow: 0 0 12px rgba(255,208,122,0.08);
    }

    .results{
      margin-top: 12px;
      border-top: 1px solid rgba(120,255,160,0.12);
      padding-top: 12px;
    }

    table{
      width:100%;
      border-collapse: collapse;
      font-size: 12px;
      margin-top: 8px;
    }
    th, td{
      padding: 10px 8px;
      border-bottom: 1px solid rgba(120,255,160,0.10);
      text-align:left;
    }
    th{
      text-transform: uppercase;
      letter-spacing:0.10em;
      color: rgba(183,255,191,0.70);
      font-size: 11px;
    }

    .monoSmall{ font-size: 11px; letter-spacing:0.08em; color: rgba(183,255,191,0.75); }
    .ctaRow{ display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap; }

    .rightCol .panel{ height:100%; }

    .kbd{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 8px;
      border: 1px solid rgba(120,255,160,0.16);
      background: rgba(0,0,0,0.25);
      color: rgba(183,255,191,0.80);
      font-size: 11px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame">
      <div class="terminal">
        <div class="topbar">
          <div class="title">
            <h1>DABO</h1>
            <div class="subtitle">QUARKâ€™S CHANCE ENGINE // FERENGI GAMING TERMINAL</div>
          </div>
          <div class="statusrow">
            <div class="pill" id="bankrollPill">BANKROLL: <strong id="bankrollVal">1000</strong></div>
            <div class="pill">PAYOUT: <strong>Q+ðŸŒ€+ðŸŒ€</strong> = 4000Ã— â€¢ <strong>3K</strong>=100Ã— â€¢ <strong>2K</strong>=5Ã—</div>
          </div>
        </div>

        <div class="grid">
          <!-- Left: Wheel -->
          <div class="panel" style="grid-column: 1 / span 2;">
            <h2>Wheel</h2>

            <div class="wheelWrap">
              <div class="wheelHeader">
                <div class="muted">
                  SELECT 1â€“3 SLOTS (EXCLUDING HOUSE-ONLY): <span class="warn">5â€“7</span>, <span class="warn">17â€“19</span>, <span class="warn">29â€“31</span>
                </div>
                <div class="legend">
                  <span>ðŸŸ© bettable</span>
                  <span>ðŸŸ¨ selected</span>
                  <span>ðŸŸ§ house-only</span>
                </div>
              </div>

              <div class="slotRuler" id="slotRuler"></div>

              <div class="window" id="wheelWindow">
                <div class="ringRow">
                  <div class="ringLabel"><span>RING</span><b>A</b></div>
                  <div class="viewport"><div class="track" id="trackA"></div></div>
                </div>
                <div class="ringRow">
                  <div class="ringLabel"><span>RING</span><b>B</b></div>
                  <div class="viewport"><div class="track" id="trackB"></div></div>
                </div>
                <div class="ringRow">
                  <div class="ringLabel"><span>RING</span><b>C</b></div>
                  <div class="viewport"><div class="track" id="trackC"></div></div>
                </div>
              </div>
            </div>

            <div class="results">
              <div id="statusLine" class="monoSmall">ENTER SLOTS + BET, THEN SPIN.</div>
              <div id="spinMeta" class="muted" style="margin-top:8px;"></div>

              <table id="resultsTable" style="display:none;">
                <thead>
                  <tr>
                    <th>Slot</th>
                    <th>Ring A</th>
                    <th>Ring B</th>
                    <th>Ring C</th>
                    <th>Match</th>
                    <th>Mult</th>
                    <th>Win</th>
                  </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
              </table>
            </div>
          </div>

          <!-- Right: Controls -->
          <div class="panel rightCol">
            <h2>Controls</h2>

            <div class="ctaRow">
              <div style="flex:1; min-width: 260px;">
                <label for="slotsInput">SLOTS (SPACE/COMMA SEPARATED)</label>
                <input id="slotsInput" placeholder="e.g. 3 12 21" autocomplete="off" />
                <div id="slotsHint" class="muted" style="margin-top:6px;"></div>
              </div>

              <div style="flex:1; min-width: 220px;">
                <label for="betInput">BET PER SLOT</label>
                <input id="betInput" placeholder="10" autocomplete="off" />
                <div id="betHint" class="muted" style="margin-top:6px;"></div>
              </div>
            </div>

            <div class="ctaRow" style="margin-top:12px;">
              <button id="spinBtn">Spin</button>
              <button id="resetBtn" title="Reset bankroll + offsets">Reset</button>
            </div>

            <div class="muted" style="margin-top: 14px;">
              Tip: press <span class="kbd">Enter</span> in a field to spin.
            </div>

            <div class="panel" style="margin-top: 14px; background: linear-gradient(180deg, rgba(12,26,19,0.78), rgba(6,12,9,0.82));">
              <h2>Symbols</h2>
              <div class="muted" id="symbolKey"></div>
            </div>

          </div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ----------------------------- Config -----------------------------
  const SLOTS = 36;
  const MIN_BET = 10;
  const MAX_BET = 100;
  const UNBETTABLE = new Set([5,6,7,17,18,19,29,30,31]);

  const SYMBOLS = {
    BAR: 'BAR',
    ORB: 'ORB',
    COMET: 'COMET',
    BOLT: 'BOLT',
    MOON: 'MOON',
    SUN: 'SUN',
    SWIRL: 'SWIRL',
    DS9: 'DS9',
    QUARK: 'QUARK',
  };

  // Ferengi-ish glyphs (kept simple + consistent on most fonts)
  const GLYPH = {
    BAR: 'â–®â–®',
    ORB: 'â—',
    COMET: 'â˜„',
    BOLT: 'âš¡',
    MOON: 'â˜¾',
    SUN:  'â˜‰',
    SWIRL:'ðŸŒ€',
    DS9:  'â¬¡',
    QUARK:'Q',
  };

  const COMMON_PATTERN = [
    SYMBOLS.BAR, SYMBOLS.ORB, SYMBOLS.COMET, SYMBOLS.BOLT,
    SYMBOLS.MOON, SYMBOLS.SUN, SYMBOLS.BOLT, SYMBOLS.ORB,
  ];

  function buildRing(seedShift = 0) {
    const ring = Array.from({ length: SLOTS }, (_, i) => COMMON_PATTERN[(i + seedShift) % COMMON_PATTERN.length]);

    // Special icons (1-based)
    ring[17 - 1] = SYMBOLS.QUARK;
    ring[8 - 1]  = SYMBOLS.SWIRL;
    ring[28 - 1] = SYMBOLS.SWIRL;
    ring[11 - 1] = SYMBOLS.DS9;
    ring[22 - 1] = SYMBOLS.DS9;
    ring[34 - 1] = SYMBOLS.DS9;

    return ring;
  }

  const RING_A = buildRing(0);
  const RING_B = buildRing(3);
  const RING_C = buildRing(5);

  // -------------------------- RNG (browser crypto) ------------------
  function randInt(minInclusive, maxExclusive) {
    const range = maxExclusive - minInclusive;
    const maxUint = 0xFFFFFFFF;
    const limit = maxUint - (maxUint % range);

    const buf = new Uint32Array(1);
    let x;
    do {
      crypto.getRandomValues(buf);
      x = buf[0];
    } while (x >= limit);

    return minInclusive + (x % range);
  }

  // -------------------------- Game Mechanics ------------------------
  function payoutMultiplier([sa, sb, sc]) {
    const trio = [sa, sb, sc].slice().sort().join('|');
    const jackpot = [SYMBOLS.QUARK, SYMBOLS.SWIRL, SYMBOLS.SWIRL].slice().sort().join('|');
    if (trio === jackpot) return 4000;
    if (sa === sb && sb === sc) return 100;
    if (sa === sb || sa === sc || sb === sc) return 5;
    return 0;
  }

  function isBettable(slot1Based) {
    return slot1Based >= 1 && slot1Based <= SLOTS && !UNBETTABLE.has(slot1Based);
  }

  function parseSlots(raw) {
    const parts = raw.split(/[\s,]+/).filter(Boolean);
    const nums = parts.map(p => Number(p)).filter(n => Number.isInteger(n));
    const unique = [...new Set(nums)];
    return unique.sort((a,b) => a-b);
  }

  function symbolsAtSlot(slot1Based, offsets) {
    const i = (slot1Based - 1) % SLOTS;
    const sa = RING_A[(i + offsets.a) % SLOTS];
    const sb = RING_B[(i + offsets.b) % SLOTS];
    const sc = RING_C[(i + offsets.c) % SLOTS];
    return [sa, sb, sc];
  }

  function matchLabel(mult) {
    if (mult === 4000) return 'JACK';
    if (mult === 100) return '3K';
    if (mult === 5) return '2K';
    return '--';
  }

  // ------------------------------ DOM -------------------------------
  const el = {
    bankrollVal: document.getElementById('bankrollVal'),
    slotsInput: document.getElementById('slotsInput'),
    betInput: document.getElementById('betInput'),
    slotsHint: document.getElementById('slotsHint'),
    betHint: document.getElementById('betHint'),
    spinBtn: document.getElementById('spinBtn'),
    resetBtn: document.getElementById('resetBtn'),
    statusLine: document.getElementById('statusLine'),
    spinMeta: document.getElementById('spinMeta'),

    slotRuler: document.getElementById('slotRuler'),
    trackA: document.getElementById('trackA'),
    trackB: document.getElementById('trackB'),
    trackC: document.getElementById('trackC'),

    resultsTable: document.getElementById('resultsTable'),
    resultsBody: document.getElementById('resultsBody'),
    symbolKey: document.getElementById('symbolKey'),
  };

  // ------------------------ Visual Track Setup ----------------------
  // Tracks are built as [ring] repeated 3 times to allow long scrolling.
  function buildTrack(trackEl, ring, ringId) {
    trackEl.innerHTML = '';
    const makeCell = (sym, idx1Based) => {
      const d = document.createElement('div');
      d.className = 'cell';
      d.dataset.slot = String(idx1Based);   // slot position (1..36)
      d.dataset.sym = sym;
      d.dataset.ring = ringId;

      const g = document.createElement('div');
      g.className = 'g';
      g.textContent = GLYPH[sym] ?? sym[0];

      const t = document.createElement('div');
      t.className = 't';
      t.textContent = sym;

      d.appendChild(g);
      d.appendChild(t);

      // Mark house-only positions visually on the wheel cells too
      if (UNBETTABLE.has(idx1Based)) d.classList.add('house');

      return d;
    };

    // repeat 3 copies
    for (let rep = 0; rep < 3; rep++) {
      for (let i = 0; i < SLOTS; i++) {
        trackEl.appendChild(makeCell(ring[i], i + 1));
      }
    }
  }

  function buildRuler() {
    el.slotRuler.innerHTML = '';
    for (let i = 1; i <= SLOTS; i++) {
      const d = document.createElement('div');
      d.textContent = String(i);
      if (UNBETTABLE.has(i)) d.classList.add('house');
      d.dataset.slot = String(i);
      el.slotRuler.appendChild(d);
    }
  }

  function buildSymbolKey() {
    const order = [SYMBOLS.QUARK, SYMBOLS.SWIRL, SYMBOLS.DS9, SYMBOLS.SUN, SYMBOLS.MOON, SYMBOLS.BOLT, SYMBOLS.COMET, SYMBOLS.ORB, SYMBOLS.BAR];
    el.symbolKey.innerHTML = order.map(s => {
      const g = GLYPH[s] ?? s[0];
      return `<div style="display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 10px;border:1px solid rgba(120,255,160,0.10);border-radius:12px;background:rgba(0,0,0,0.18);margin:6px 0;">
        <span style="font-size:16px">${g}</span>
        <span style="color:rgba(183,255,191,0.78);letter-spacing:0.08em;">${s}</span>
      </div>`;
    }).join('');
  }

  // ------------------------ Animation Engine ------------------------
  // We animate by shifting the track left by N "cells". Track starts centered in copy #2.
  const state = {
    bankroll: 1000,
    // absolute shifts in cells (can grow)
    shiftA: SLOTS + randInt(0, SLOTS),
    shiftB: SLOTS + randInt(0, SLOTS),
    shiftC: SLOTS + randInt(0, SLOTS),
    spinning: false,
    selectedSlots: [],
  };

  function cellPx() {
    const root = getComputedStyle(document.documentElement);
    const v = root.getPropertyValue('--cell').trim();
    // v is like "clamp(28px, 3.2vw, 48px)" so we measure actual via a temp element.
    const tmp = document.createElement('div');
    tmp.style.width = 'var(--cell)';
    tmp.style.position = 'absolute';
    tmp.style.visibility = 'hidden';
    document.body.appendChild(tmp);
    const w = tmp.getBoundingClientRect().width;
    tmp.remove();
    return w;
  }

  function gapPx() {
    const root = getComputedStyle(document.documentElement);
    const v = root.getPropertyValue('--gap').trim();
    // v should be px; parseFloat safe
    return parseFloat(v) || 6;
  }

  function translateForShift(shiftCells) {
    const w = cellPx();
    const g = gapPx();
    const stride = w + g;
    return -shiftCells * stride;
  }

  function applyShift(trackEl, shiftCells) {
    trackEl.style.transform = `translate3d(${translateForShift(shiftCells)}px,0,0)`;
  }

  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  function animateShift({ trackEl, from, to, ms }) {
    return new Promise(resolve => {
      const start = performance.now();
      const step = (now) => {
        const t = Math.min(1, (now - start) / ms);
        const e = easeOutCubic(t);
        const cur = from + (to - from) * e;
        applyShift(trackEl, cur);
        if (t < 1) requestAnimationFrame(step);
        else resolve();
      };
      requestAnimationFrame(step);
    });
  }

  function targetShift(currentShiftAbs, finalOffset) {
    // We want: targetShiftAbs % SLOTS == finalOffset, with lots of extra spins.
    const curMod = ((currentShiftAbs % SLOTS) + SLOTS) % SLOTS;
    const delta = (finalOffset - curMod + SLOTS) % SLOTS;
    const extraRevs = randInt(5, 11); // 5..10 full revolutions
    return currentShiftAbs + extraRevs * SLOTS + delta;
  }

  // ------------------------ UI Helpers -----------------------------
  function setStatus(msg, kind='muted') {
    el.statusLine.className = `monoSmall ${kind}`;
    el.statusLine.textContent = msg;
  }

  function updateBankroll() {
    el.bankrollVal.textContent = String(state.bankroll);
  }

  function setSpinning(on) {
    state.spinning = on;
    el.spinBtn.disabled = on;
    el.resetBtn.disabled = on;
    el.slotsInput.disabled = on;
    el.betInput.disabled = on;
  }

  function highlightSelected(slots) {
    state.selectedSlots = slots;

    // ruler
    [...el.slotRuler.children].forEach(d => {
      const s = Number(d.dataset.slot);
      d.classList.toggle('selected', slots.includes(s));
    });

    // wheel cells (for each copy)
    const tracks = [el.trackA, el.trackB, el.trackC];
    for (const tr of tracks) {
      [...tr.children].forEach(cell => {
        const s = Number(cell.dataset.slot);
        cell.classList.toggle('selected', slots.includes(s));
      });
    }
  }

  function validateInputs() {
    const slots = parseSlots(el.slotsInput.value.trim());
    if (slots.length < 1 || slots.length > 3) {
      el.slotsHint.textContent = 'Pick 1â€“3 unique bettable slots.';
      return { ok:false, reason:'INVALID SLOT COUNT' };
    }
    if (!slots.every(isBettable)) {
      el.slotsHint.innerHTML = `One or more slots are <span class="warn">house-only</span> or out of range.`;
      return { ok:false, reason:'HOUSE-ONLY SLOT SELECTED' };
    }
    el.slotsHint.textContent = `Selected: ${slots.join(', ')}`;

    const betRaw = el.betInput.value.trim();
    const bet = betRaw === '' ? MIN_BET : Number(betRaw);
    if (!Number.isInteger(bet)) {
      el.betHint.textContent = 'Bet must be a whole number.';
      return { ok:false, reason:'INVALID BET' };
    }
    const maxAffordablePerSlot = Math.floor(state.bankroll / slots.length);
    const effectiveMax = Math.min(MAX_BET, maxAffordablePerSlot);
    if (bet < MIN_BET || bet > effectiveMax) {
      el.betHint.textContent = `Bet per slot must be ${MIN_BET}â€“${effectiveMax} (based on bankroll).`;
      return { ok:false, reason:'BET OUT OF RANGE' };
    }

    el.betHint.textContent = `Total stake: ${bet * slots.length}.`;
    return { ok:true, slots, bet };
  }

  function renderResults(rows) {
    el.resultsBody.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.slot}</td>
        <td>${GLYPH[r.sa] ?? r.sa}</td>
        <td>${GLYPH[r.sb] ?? r.sb}</td>
        <td>${GLYPH[r.sc] ?? r.sc}</td>
        <td>${r.match}</td>
        <td>${r.mult}</td>
        <td>${r.win}</td>
      `;
      el.resultsBody.appendChild(tr);
    }
    el.resultsTable.style.display = '';
  }

  // ------------------------ Spin Orchestration ----------------------
  async function spin() {
    if (state.spinning) return;

    const v = validateInputs();
    if (!v.ok) {
      setStatus(`ERROR // ${v.reason}`, 'bad');
      return;
    }

    const { slots, bet } = v;
    highlightSelected(slots);

    const stake = bet * slots.length;
    state.bankroll -= stake;
    updateBankroll();

    setSpinning(true);
    setStatus('SPINNING // WATCH THE WHEEL', 'warn');
    el.spinMeta.textContent = 'Synchronizing ringsâ€¦';

    // Final offsets (0..35) for each ring
    const final = { a: randInt(0, SLOTS), b: randInt(0, SLOTS), c: randInt(0, SLOTS) };

    // Convert to target absolute shift values
    const toA = targetShift(state.shiftA, final.a);
    const toB = targetShift(state.shiftB, final.b);
    const toC = targetShift(state.shiftC, final.c);

    // Animate in sequence (A then B then C), slightly different durations
    const aMs = randInt(850, 1100);
    const bMs = randInt(1050, 1350);
    const cMs = randInt(1200, 1600);

    // Kick all moving quickly, then let them stop sequentially
    // Start all three with a short burst for drama:
    await Promise.all([
      animateShift({ trackEl: el.trackA, from: state.shiftA, to: state.shiftA + SLOTS * 2, ms: 420 }),
      animateShift({ trackEl: el.trackB, from: state.shiftB, to: state.shiftB + SLOTS * 2, ms: 420 }),
      animateShift({ trackEl: el.trackC, from: state.shiftC, to: state.shiftC + SLOTS * 2, ms: 420 }),
    ]);

    await animateShift({ trackEl: el.trackA, from: state.shiftA + SLOTS*2, to: toA, ms: aMs });
    state.shiftA = toA;

    await animateShift({ trackEl: el.trackB, from: state.shiftB + SLOTS*2, to: toB, ms: bMs });
    state.shiftB = toB;

    await animateShift({ trackEl: el.trackC, from: state.shiftC + SLOTS*2, to: toC, ms: cMs });
    state.shiftC = toC;

    // Compute results using final offsets
    const rows = [];
    let totalWin = 0;

    for (const slot of slots) {
      const [sa, sb, sc] = symbolsAtSlot(slot, final);
      const mult = payoutMultiplier([sa, sb, sc]);
      const win = bet * mult;
      totalWin += win;
      rows.push({ slot, sa, sb, sc, mult, win, match: matchLabel(mult) });
    }

    state.bankroll += totalWin;
    updateBankroll();

    el.spinMeta.textContent = `Offsets: A=${final.a}, B=${final.b}, C=${final.c} â€” Staked ${stake}, Won ${totalWin}, Net ${totalWin - stake}`;

    renderResults(rows);

    if (totalWin > 0) setStatus('DABO! // PROFIT ACHIEVED', 'ok');
    else setStatus('NO HIT // RECONSIDER YOUR INVESTMENT STRATEGY', 'muted');

    if (state.bankroll < MIN_BET) {
      setStatus('INSUFFICIENT FUNDS // ACQUIRE MORE LATINUM (RESET)', 'bad');
      el.spinBtn.disabled = true;
    }

    setSpinning(false);
  }

  function reset() {
    state.bankroll = 1000;
    state.shiftA = SLOTS + randInt(0, SLOTS);
    state.shiftB = SLOTS + randInt(0, SLOTS);
    state.shiftC = SLOTS + randInt(0, SLOTS);
    updateBankroll();
    applyShift(el.trackA, state.shiftA);
    applyShift(el.trackB, state.shiftB);
    applyShift(el.trackC, state.shiftC);
    el.resultsTable.style.display = 'none';
    el.spinMeta.textContent = '';
    setStatus('ENTER SLOTS + BET, THEN SPIN.', 'muted');
    el.spinBtn.disabled = false;
  }

  // ------------------------------ Init ------------------------------
  buildRuler();
  buildTrack(el.trackA, RING_A, 'A');
  buildTrack(el.trackB, RING_B, 'B');
  buildTrack(el.trackC, RING_C, 'C');
  buildSymbolKey();

  // Initial placement
  applyShift(el.trackA, state.shiftA);
  applyShift(el.trackB, state.shiftB);
  applyShift(el.trackC, state.shiftC);
  updateBankroll();

  // Input listeners
  el.slotsInput.addEventListener('input', () => {
    const slots = parseSlots(el.slotsInput.value.trim()).filter(n => n>=1 && n<=SLOTS);
    highlightSelected(slots.slice(0,3));
    validateInputs();
  });
  el.betInput.addEventListener('input', validateInputs);

  // Spin on Enter
  [el.slotsInput, el.betInput].forEach(inp => {
    inp.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') spin();
    });
  });

  el.spinBtn.addEventListener('click', spin);
  el.resetBtn.addEventListener('click', reset);

  highlightSelected([]);
  validateInputs();
})();
</script>
</body>
</html>

